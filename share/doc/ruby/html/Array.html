<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>class Array - Documentation for Ruby 3.4</title>

  <meta name="keywords" content="ruby,class,Array">

    <meta name="description" content="class Array: Array_(data_structure)]. An element may be any object (even another array); elements may be any mixture of objects of different types.">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>



  <ul class="link-list" role="directory">
              <li>
            <details open>
              <summary>      <a href="#class-Array-label-Array+Indexes">Array Indexes</a>
</summary>
              <ul class="link-list" role="directory">
                          <li>      <a href="#class-Array-label-In-Range+and+Out-of-Range+Indexes">In-Range and Out-of-Range Indexes</a>
          <li>      <a href="#class-Array-label-Effective+Index">Effective Index</a>

              </ul>
            </details>
          </li>
          <li>      <a href="#class-Array-label-Creating+Arrays">Creating Arrays</a>
          <li>      <a href="#class-Array-label-Example+Usage">Example Usage</a>
          <li>      <a href="#class-Array-label-Accessing+Elements">Accessing Elements</a>
          <li>      <a href="#class-Array-label-Obtaining+Information+about+an+Array">Obtaining Information about an <code>Array</code></a>
          <li>      <a href="#class-Array-label-Adding+Items+to+Arrays">Adding Items to Arrays</a>
          <li>      <a href="#class-Array-label-Removing+Items+from+an+Array">Removing Items from an <code>Array</code></a>
          <li>      <a href="#class-Array-label-Iterating+over+Arrays">Iterating over Arrays</a>
          <li>
            <details open>
              <summary>      <a href="#class-Array-label-Selecting+Items+from+an+Array">Selecting Items from an <code>Array</code></a>
</summary>
              <ul class="link-list" role="directory">
                          <li>      <a href="#class-Array-label-Non-destructive+Selection">Non-destructive Selection</a>
          <li>      <a href="#class-Array-label-Destructive+Selection">Destructive Selection</a>

              </ul>
            </details>
          </li>
          <li>
            <details open>
              <summary>      <a href="#class-Array-label-What-27s+Here">What’s Here</a>
</summary>
              <ul class="link-list" role="directory">
                          <li>      <a href="#class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an <code>Array</code></a>
          <li>      <a href="#class-Array-label-Methods+for+Querying">Methods for Querying</a>
          <li>      <a href="#class-Array-label-Methods+for+Comparing">Methods for Comparing</a>
          <li>      <a href="#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>
          <li>      <a href="#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>
          <li>      <a href="#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>
          <li>      <a href="#class-Array-label-Methods+for+Combining">Methods for Combining</a>
          <li>      <a href="#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>
          <li>      <a href="#class-Array-label-Methods+for+Converting">Methods for Converting</a>
          <li>      <a href="#class-Array-label-Other+Methods">Other Methods</a>

              </ul>
            </details>
          </li>

  </ul>
</div>

  
  <div id="parent-class-section" class="nav-section">
  <h3>Ancestors</h3>
  <ul><li><a href="Object.html">Object</a><ul><li><a href="BasicObject.html">BasicObject</a></li></ul></li></ul>
</div>

  
<div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
    <li><a class="include" href="Enumerable.html">Enumerable</a>
  </ul>
</div>

  
  
  <div class="nav-section">
    <h3>Class Methods</h3>
    <ul class="link-list" role="directory">
      <li ><a href="#method-c-5B-5D">[]</a></li>
      <li ><a href="#method-c-new">new</a></li>
      <li ><a href="#method-c-try_convert">try_convert</a></li>
    </ul>
  </div>



  <div class="nav-section">
    <h3>Instance Methods</h3>
    <ul class="link-list" role="directory">
      <li ><a href="#method-i-26">&amp;</a></li>
      <li ><a href="#method-i-2A">*</a></li>
      <li ><a href="#method-i-2B">+</a></li>
      <li ><a href="#method-i-2D">-</a></li>
      <li ><a href="#method-i-3C-3C">&lt;&lt;</a></li>
      <li ><a href="#method-i-3C-3D-3E">&lt;=&gt;</a></li>
      <li ><a href="#method-i-3D-3D">==</a></li>
      <li ><a href="#method-i-5B-5D">[]</a></li>
      <li ><a href="#method-i-5B-5D-3D">[]=</a></li>
      <li ><a href="#method-i-7C">|</a></li>
      <li ><a href="#method-i-all-3F">all?</a></li>
      <li ><a href="#method-i-any-3F">any?</a></li>
      <li ><a href="#method-i-append">append</a></li>
      <li ><a href="#method-i-assoc">assoc</a></li>
      <li ><a href="#method-i-at">at</a></li>
      <li ><a href="#method-i-bsearch">bsearch</a></li>
      <li ><a href="#method-i-bsearch_index">bsearch_index</a></li>
      <li ><a href="#method-i-clear">clear</a></li>
      <li ><a href="#method-i-collect">collect</a></li>
      <li ><a href="#method-i-collect-21">collect!</a></li>
      <li ><a href="#method-i-combination">combination</a></li>
      <li ><a href="#method-i-compact">compact</a></li>
      <li ><a href="#method-i-compact-21">compact!</a></li>
      <li ><a href="#method-i-concat">concat</a></li>
      <li ><a href="#method-i-count">count</a></li>
      <li ><a href="#method-i-cycle">cycle</a></li>
      <li ><a href="#method-i-delete">delete</a></li>
      <li ><a href="#method-i-delete_at">delete_at</a></li>
      <li ><a href="#method-i-delete_if">delete_if</a></li>
      <li ><a href="#method-i-difference">difference</a></li>
      <li ><a href="#method-i-dig">dig</a></li>
      <li ><a href="#method-i-drop">drop</a></li>
      <li ><a href="#method-i-drop_while">drop_while</a></li>
      <li ><a href="#method-i-each">each</a></li>
      <li ><a href="#method-i-each_index">each_index</a></li>
      <li ><a href="#method-i-empty-3F">empty?</a></li>
      <li ><a href="#method-i-eql-3F">eql?</a></li>
      <li ><a href="#method-i-fetch">fetch</a></li>
      <li ><a href="#method-i-fetch_values">fetch_values</a></li>
      <li ><a href="#method-i-fill">fill</a></li>
      <li ><a href="#method-i-filter">filter</a></li>
      <li ><a href="#method-i-filter-21">filter!</a></li>
      <li ><a href="#method-i-find_index">find_index</a></li>
      <li ><a href="#method-i-first">first</a></li>
      <li ><a href="#method-i-flatten">flatten</a></li>
      <li ><a href="#method-i-flatten-21">flatten!</a></li>
      <li ><a href="#method-i-freeze">freeze</a></li>
      <li ><a href="#method-i-hash">hash</a></li>
      <li ><a href="#method-i-include-3F">include?</a></li>
      <li ><a href="#method-i-index">index</a></li>
      <li ><a href="#method-i-initialize_copy">initialize_copy</a></li>
      <li ><a href="#method-i-insert">insert</a></li>
      <li ><a href="#method-i-inspect">inspect</a></li>
      <li ><a href="#method-i-intersect-3F">intersect?</a></li>
      <li ><a href="#method-i-intersection">intersection</a></li>
      <li ><a href="#method-i-join">join</a></li>
      <li ><a href="#method-i-keep_if">keep_if</a></li>
      <li ><a href="#method-i-last">last</a></li>
      <li ><a href="#method-i-length">length</a></li>
      <li ><a href="#method-i-map">map</a></li>
      <li ><a href="#method-i-map-21">map!</a></li>
      <li ><a href="#method-i-max">max</a></li>
      <li ><a href="#method-i-min">min</a></li>
      <li ><a href="#method-i-minmax">minmax</a></li>
      <li ><a href="#method-i-none-3F">none?</a></li>
      <li ><a href="#method-i-one-3F">one?</a></li>
      <li ><a href="#method-i-pack">pack</a></li>
      <li ><a href="#method-i-permutation">permutation</a></li>
      <li ><a href="#method-i-pop">pop</a></li>
      <li ><a href="#method-i-prepend">prepend</a></li>
      <li ><a href="#method-i-product">product</a></li>
      <li ><a href="#method-i-push">push</a></li>
      <li ><a href="#method-i-rassoc">rassoc</a></li>
      <li ><a href="#method-i-reject">reject</a></li>
      <li ><a href="#method-i-reject-21">reject!</a></li>
      <li ><a href="#method-i-repeated_combination">repeated_combination</a></li>
      <li ><a href="#method-i-repeated_permutation">repeated_permutation</a></li>
      <li ><a href="#method-i-replace">replace</a></li>
      <li ><a href="#method-i-reverse">reverse</a></li>
      <li ><a href="#method-i-reverse-21">reverse!</a></li>
      <li ><a href="#method-i-reverse_each">reverse_each</a></li>
      <li ><a href="#method-i-rindex">rindex</a></li>
      <li ><a href="#method-i-rotate">rotate</a></li>
      <li ><a href="#method-i-rotate-21">rotate!</a></li>
      <li ><a href="#method-i-sample">sample</a></li>
      <li ><a href="#method-i-select">select</a></li>
      <li ><a href="#method-i-select-21">select!</a></li>
      <li ><a href="#method-i-shelljoin">shelljoin</a></li>
      <li ><a href="#method-i-shift">shift</a></li>
      <li ><a href="#method-i-shuffle">shuffle</a></li>
      <li ><a href="#method-i-shuffle-21">shuffle!</a></li>
      <li ><a href="#method-i-size">size</a></li>
      <li ><a href="#method-i-slice">slice</a></li>
      <li ><a href="#method-i-slice-21">slice!</a></li>
      <li ><a href="#method-i-sort">sort</a></li>
      <li ><a href="#method-i-sort-21">sort!</a></li>
      <li ><a href="#method-i-sort_by-21">sort_by!</a></li>
      <li ><a href="#method-i-sum">sum</a></li>
      <li ><a href="#method-i-take">take</a></li>
      <li ><a href="#method-i-take_while">take_while</a></li>
      <li ><a href="#method-i-to_a">to_a</a></li>
      <li ><a href="#method-i-to_ary">to_ary</a></li>
      <li ><a href="#method-i-to_h">to_h</a></li>
      <li ><a href="#method-i-to_s">to_s</a></li>
      <li ><a href="#method-i-transpose">transpose</a></li>
      <li ><a href="#method-i-union">union</a></li>
      <li ><a href="#method-i-uniq">uniq</a></li>
      <li ><a href="#method-i-uniq-21">uniq!</a></li>
      <li ><a href="#method-i-unshift">unshift</a></li>
      <li ><a href="#method-i-values_at">values_at</a></li>
      <li ><a href="#method-i-zip">zip</a></li>
    </ul>
  </div>



  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.10.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-labelledby="class-Array">
  <h1 id="class-Array" class="anchor-link class">
    class Array
  </h1>

  <section class="description">
    
<p>An Array object is an ordered, integer-indexed collection of objects, called <em>elements</em>; the object represents an <a href="https://en.wikipedia.org/wiki/Array_(data_structure)">array data structure</a>.</p>

<p>An element may be any object (even another array); elements may be any mixture of objects of different types.</p>

<p>Important data structures that use arrays include:</p>
<ul><li>
<p><a href="https://en.wikipedia.org/wiki/Coordinate_vector">Coordinate vector</a>.</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">Matrix</a>.</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Heap</a>.</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Hash_table">Hash table</a>.</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Double-ended_queue">Deque (double-ended queue)</a>.</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a>.</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a>.</p>
</li></ul>

<p>There are also array-like data structures:</p>
<ul><li>
<p><a href="https://en.wikipedia.org/wiki/Associative_array">Associative array</a> (see <a href="Hash.html"><code>Hash</code></a>).</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Directory_(computing)">Directory</a> (see <a href="Dir.html"><code>Dir</code></a>).</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Environment_variable">Environment</a> (see <a href="ENV.html"><code>ENV</code></a>).</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a> (see <a href="Set.html"><code>Set</code></a>).</p>
</li><li>
<p><a href="https://en.wikipedia.org/wiki/String_(computer_science)">String</a> (see <a href="String.html"><code>String</code></a>).</p>
</li></ul>

<h2 id="class-Array-label-Array+Indexes">Array Indexes<span><a href="#class-Array-label-Array+Indexes">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Array indexing starts at 0, as in C or Java.</p>

<p>A non-negative index is an offset from the first element:</p>
<ul><li>
<p>Index 0 indicates the first element.</p>
</li><li>
<p>Index 1 indicates the second element.</p>
</li><li>
<p>…</p>
</li></ul>

<p>A negative index is an offset, backwards, from the end of the array:</p>
<ul><li>
<p>Index -1 indicates the last element.</p>
</li><li>
<p>Index -2 indicates the next-to-last element.</p>
</li><li>
<p>…</p>
</li></ul>

<h3 id="class-Array-label-In-Range+and+Out-of-Range+Indexes">In-Range and Out-of-Range Indexes<span><a href="#class-Array-label-In-Range+and+Out-of-Range+Indexes">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>A non-negative index is <em>in range</em> if and only if it is smaller than the size of the array.  For a 3-element array:</p>
<ul><li>
<p>Indexes 0 through 2 are in range.</p>
</li><li>
<p>Index 3 is out of range.</p>
</li></ul>

<p>A negative index is <em>in range</em> if and only if its absolute value is not larger than the size of the array.  For a 3-element array:</p>
<ul><li>
<p>Indexes -1 through -3 are in range.</p>
</li><li>
<p>Index -4 is out of range.</p>
</li></ul>

<h3 id="class-Array-label-Effective+Index">Effective Index<span><a href="#class-Array-label-Effective+Index">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Although the effective index into an array is always an integer, some methods (both within class Array and elsewhere) accept one or more non-integer arguments that are <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible objects</a>.</p>

<h2 id="class-Array-label-Creating+Arrays">Creating Arrays<span><a href="#class-Array-label-Creating+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can create an Array object explicitly with:</p>
<ul><li>
<p>An <a href="syntax/literals_rdoc.html#label-Array+Literals">array literal</a>:</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-string">&#39;one&#39;</span>, <span class="ruby-value">:one</span>, [<span class="ruby-value">2</span>, <span class="ruby-string">&#39;two&#39;</span>, <span class="ruby-value">:two</span>]]
</pre>
</li><li>
<p>A <a href="syntax/literals_rdoc.html#label-25w+and+-25W-3A+String-Array+Literals">%w or %W string-array Literal</a>:</p>

<pre class="ruby"><span class="ruby-node">%w[foo bar baz]</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="ruby-node">%w[1 % *]</span>       <span class="ruby-comment"># =&gt; [&quot;1&quot;, &quot;%&quot;, &quot;*&quot;]</span>
</pre>
</li><li>
<p>A <a href="syntax/literals_rdoc.html#label-25i+and+-25I-3A+Symbol-Array+Literals">%i or %I symbol-array Literal</a>:</p>

<pre class="ruby"><span class="ruby-node">%i[foo bar baz]</span> <span class="ruby-comment"># =&gt; [:foo, :bar, :baz]</span>
<span class="ruby-node">%i[1 % *]</span>       <span class="ruby-comment"># =&gt; [:&quot;1&quot;, :%, :*]</span>
</pre>
</li><li>
<p>Method <a href="Kernel.html#method-i-Array"><code>Kernel#Array</code></a>:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>([<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>])             <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;]</span>
<span class="ruby-constant">Array</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>)                   <span class="ruby-comment"># =&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-constant">Array</span>(<span class="ruby-value">key:</span> <span class="ruby-value">:value</span>)            <span class="ruby-comment"># =&gt; [[:key, :value]]</span>
<span class="ruby-constant">Array</span>(<span class="ruby-keyword">nil</span>)                    <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-constant">Array</span>(<span class="ruby-value">1</span>)                      <span class="ruby-comment"># =&gt; [1]</span>
<span class="ruby-constant">Array</span>({<span class="ruby-value">:a</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-value">:b</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;b&quot;</span>}) <span class="ruby-comment"># =&gt; [[:a, &quot;a&quot;], [:b, &quot;b&quot;]]</span>
</pre>
</li><li>
<p>Method <a href="Array.html#method-c-new"><code>Array.new</code></a>:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>               <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)            <span class="ruby-comment"># =&gt; [nil, nil, nil]</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>) {<span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>} <span class="ruby-comment"># =&gt; [{}, {}, {}, {}]</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>, <span class="ruby-keyword">true</span>)      <span class="ruby-comment"># =&gt; [true, true, true]</span>
</pre>

<p>Note that the last example above populates the array with references to the same object. This is recommended only in cases where that object is a natively immutable object such as a symbol, a numeric, <code>nil</code>, <code>true</code>, or <code>false</code>.</p>

<p>Another way to create an array with various objects, using a block; this usage is safe for mutable objects such as hashes, strings or other arrays:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span>
</pre>

<p>Here is a way to create a multi-dimensional array:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>) {<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)}
<span class="ruby-comment"># =&gt; [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]</span>
</pre>
</li></ul>

<p>A number of Ruby methods, both in the core and in the standard library, provide instance method <a href="Array.html#method-i-to_a"><code>to_a</code></a>, which converts an object to an array.</p>
<ul><li>
<p><a href="ARGF.html#method-i-to_a"><code>ARGF#to_a</code></a></p>
</li><li>
<p><a href="Array.html#method-i-to_a"><code>Array#to_a</code></a></p>
</li><li>
<p><a href="Enumerable.html#method-i-to_a"><code>Enumerable#to_a</code></a></p>
</li><li>
<p><a href="Hash.html#method-i-to_a"><code>Hash#to_a</code></a></p>
</li><li>
<p><a href="MatchData.html#method-i-to_a"><code>MatchData#to_a</code></a></p>
</li><li>
<p><a href="NilClass.html#method-i-to_a"><code>NilClass#to_a</code></a></p>
</li><li>
<p><a href="OptionParser.html#method-i-to_a"><code>OptionParser#to_a</code></a></p>
</li><li>
<p><a href="Range.html#method-i-to_a"><code>Range#to_a</code></a></p>
</li><li>
<p><a href="Set.html#method-i-to_a"><code>Set#to_a</code></a></p>
</li><li>
<p><a href="Struct.html#method-i-to_a"><code>Struct#to_a</code></a></p>
</li><li>
<p><a href="Time.html#method-i-to_a"><code>Time#to_a</code></a></p>
</li><li>
<p><a href="Benchmark/Tms.html#method-i-to_a"><code>Benchmark::Tms#to_a</code></a></p>
</li><li>
<p>CSV::Table#to_a</p>
</li><li>
<p><a href="Enumerator/Lazy.html#method-i-to_a"><code>Enumerator::Lazy#to_a</code></a></p>
</li><li>
<p>Gem::List#to_a</p>
</li><li>
<p><a href="Gem/NameTuple.html#method-i-to_a"><code>Gem::NameTuple#to_a</code></a></p>
</li><li>
<p><a href="Gem/Platform.html#method-i-to_a"><code>Gem::Platform#to_a</code></a></p>
</li><li>
<p><a href="Gem/RequestSet/Lockfile/Tokenizer.html#method-i-to_a"><code>Gem::RequestSet::Lockfile::Tokenizer#to_a</code></a></p>
</li><li>
<p><a href="Gem/SourceList.html#method-i-to_a"><code>Gem::SourceList#to_a</code></a></p>
</li><li>
<p><a href="OpenSSL/X509/Extension.html#method-i-to_a"><code>OpenSSL::X509::Extension#to_a</code></a></p>
</li><li>
<p><a href="OpenSSL/X509/Name.html#method-i-to_a"><code>OpenSSL::X509::Name#to_a</code></a></p>
</li><li>
<p>Racc::ISet#to_a</p>
</li><li>
<p>Rinda::RingFinger#to_a</p>
</li><li>
<p>Ripper::Lexer::Elem#to_a</p>
</li><li>
<p><a href="RubyVM/InstructionSequence.html#method-i-to_a"><code>RubyVM::InstructionSequence#to_a</code></a></p>
</li><li>
<p><a href="YAML/DBM.html#method-i-to_a"><code>YAML::DBM#to_a</code></a></p>
</li></ul>

<h2 id="class-Array-label-Example+Usage">Example Usage<span><a href="#class-Array-label-Example+Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In addition to the methods it mixes in through the <a href="Enumerable.html"><code>Enumerable</code></a> module, the <a href="Array.html"><code>Array</code></a> class has proprietary methods for accessing, searching and otherwise manipulating arrays.</p>

<p>Some of the more common ones are illustrated below.</p>

<h2 id="class-Array-label-Accessing+Elements">Accessing Elements<span><a href="#class-Array-label-Accessing+Elements">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Elements in an array can be retrieved using the <a href="Array.html#method-i-5B-5D"><code>Array#[]</code></a> method.  It can take a single integer argument (a numeric index), a pair of arguments (start and length) or a range. Negative indices start counting from the end, with -1 being the last element.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>[<span class="ruby-value">2</span>]    <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">100</span>]  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">-3</span>]   <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment">#=&gt; [3, 4, 5]</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>] <span class="ruby-comment">#=&gt; [2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] <span class="ruby-comment">#=&gt; [2, 3, 4]</span>
</pre>

<p>Another way to access a particular array element is by using the <a href="Array.html#method-i-at"><code>at</code></a> method</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>) <span class="ruby-comment">#=&gt; 1</span>
</pre>

<p>The <a href="Array.html#method-i-slice"><code>slice</code></a> method works in an identical manner to <a href="Array.html#method-i-5B-5D"><code>Array#[]</code></a>.</p>

<p>To raise an error for indices outside of the array bounds or else to provide a default value when that happens, you can use <a href="Array.html#method-i-fetch"><code>fetch</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>, <span class="ruby-string">&#39;e&#39;</span>, <span class="ruby-string">&#39;f&#39;</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">100</span>) <span class="ruby-comment">#=&gt; IndexError: index 100 outside of array bounds: -6...6</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">100</span>, <span class="ruby-string">&quot;oops&quot;</span>) <span class="ruby-comment">#=&gt; &quot;oops&quot;</span>
</pre>

<p>The special methods <a href="Array.html#method-i-first"><code>first</code></a> and <a href="Array.html#method-i-last"><code>last</code></a> will return the first and last elements of an array, respectively.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">first</span> <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">last</span>  <span class="ruby-comment">#=&gt; 6</span>
</pre>

<p>To return the first <code>n</code> elements of an array, use <a href="Array.html#method-i-take"><code>take</code></a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<p><a href="Array.html#method-i-drop"><code>drop</code></a> does the opposite of <a href="Array.html#method-i-take"><code>take</code></a>, by returning the elements after <code>n</code> elements have been dropped:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
</pre>

<h2 id="class-Array-label-Obtaining+Information+about+an+Array">Obtaining Information about an <a href="Array.html"><code>Array</code></a><span><a href="#class-Array-label-Obtaining+Information+about+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Arrays keep track of their own length at all times.  To query an array about the number of elements it contains, use <a href="Array.html#method-i-length"><code>length</code></a>, <a href="Array.html#method-i-count"><code>count</code></a> or <a href="Array.html#method-i-size"><code>size</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span> = [<span class="ruby-string">&#39;Chrome&#39;</span>, <span class="ruby-string">&#39;Firefox&#39;</span>, <span class="ruby-string">&#39;Safari&#39;</span>, <span class="ruby-string">&#39;Opera&#39;</span>, <span class="ruby-string">&#39;IE&#39;</span>]
<span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment">#=&gt; 5</span>
<span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">count</span> <span class="ruby-comment">#=&gt; 5</span>
</pre>

<p>To check whether an array contains any elements at all</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>To check whether a particular item is included in the array</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&#39;Konqueror&#39;</span>) <span class="ruby-comment">#=&gt; false</span>
</pre>

<h2 id="class-Array-label-Adding+Items+to+Arrays">Adding Items to Arrays<span><a href="#class-Array-label-Adding+Items+to+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Items can be added to the end of an array by using either <a href="Array.html#method-i-push"><code>push</code></a> or <a href="Array.html#method-i-3C-3C"><code>&lt;&lt;</code></a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">push</span>(<span class="ruby-value">5</span>) <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">6</span>    <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6]</span>
</pre>

<p><a href="Array.html#method-i-unshift"><code>unshift</code></a> will add a new item to the beginning of an array.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">0</span>) <span class="ruby-comment">#=&gt; [0, 1, 2, 3, 4, 5, 6]</span>
</pre>

<p>With <a href="Array.html#method-i-insert"><code>insert</code></a> you can add a new element to an array at any position.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">3</span>, <span class="ruby-string">&#39;apple&#39;</span>)  <span class="ruby-comment">#=&gt; [0, 1, 2, &#39;apple&#39;, 3, 4, 5, 6]</span>
</pre>

<p>Using the <a href="Array.html#method-i-insert"><code>insert</code></a> method, you can also insert multiple values at once:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">3</span>, <span class="ruby-string">&#39;orange&#39;</span>, <span class="ruby-string">&#39;pear&#39;</span>, <span class="ruby-string">&#39;grapefruit&#39;</span>)
<span class="ruby-comment">#=&gt; [0, 1, 2, &quot;orange&quot;, &quot;pear&quot;, &quot;grapefruit&quot;, &quot;apple&quot;, 3, 4, 5, 6]</span>
</pre>

<h2 id="class-Array-label-Removing+Items+from+an+Array">Removing Items from an <a href="Array.html"><code>Array</code></a><span><a href="#class-Array-label-Removing+Items+from+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The method <a href="Array.html#method-i-pop"><code>pop</code></a> removes the last element in an array and returns it:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> =  [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">pop</span> <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>

<p>To retrieve and at the same time remove the first item, use <a href="Array.html#method-i-shift"><code>shift</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">shift</span> <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [2, 3, 4, 5]</span>
</pre>

<p>To delete an element at a particular index:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [2, 3, 5]</span>
</pre>

<p>To delete a particular element anywhere in an array, use <a href="Array.html#method-i-delete"><code>delete</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [1,3]</span>
</pre>

<p>A useful method if you need to remove <code>nil</code> values from an array is <a href="Array.html#method-i-compact"><code>compact</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">7</span>, <span class="ruby-string">&#39;baz&#39;</span>, <span class="ruby-keyword">nil</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">compact</span>  <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, &#39;bar&#39;, 7, &#39;baz&#39;]</span>
<span class="ruby-identifier">arr</span>          <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, nil, &#39;bar&#39;, 7, &#39;baz&#39;, nil]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">compact!</span> <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, &#39;bar&#39;, 7, &#39;baz&#39;]</span>
<span class="ruby-identifier">arr</span>          <span class="ruby-comment">#=&gt; [&#39;foo&#39;, 0, &#39;bar&#39;, 7, &#39;baz&#39;]</span>
</pre>

<p>Another common need is to remove duplicate elements from an array.</p>

<p>It has the non-destructive <a href="Array.html#method-i-uniq"><code>uniq</code></a>, and destructive method <a href="Array.html#method-i-uniq-21"><code>uniq!</code></a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">556</span>, <span class="ruby-value">6</span>, <span class="ruby-value">6</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">0</span>, <span class="ruby-value">123</span>, <span class="ruby-value">556</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">uniq</span> <span class="ruby-comment">#=&gt; [2, 5, 6, 556, 8, 9, 0, 123]</span>
</pre>

<h2 id="class-Array-label-Iterating+over+Arrays">Iterating over Arrays<span><a href="#class-Array-label-Iterating+over+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Like all classes that include the <a href="Enumerable.html"><code>Enumerable</code></a> module, <a href="Array.html"><code>Array</code></a> has an each method, which defines what elements should be iterated over and how.  In case of Array’s <a href="Array.html#method-i-each"><code>each</code></a>, all elements in the <a href="Array.html"><code>Array</code></a> instance are yielded to the supplied block in sequence.</p>

<p>Note that this operation leaves the array unchanged.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-=</span> <span class="ruby-value">10</span>, <span class="ruby-string">&quot; &quot;</span>}
<span class="ruby-comment"># prints: -9 -8 -7 -6 -5</span>
<span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>

<p>Another sometimes useful iterator is <a href="Array.html#method-i-reverse_each"><code>reverse_each</code></a> which will iterate over the elements in the array in reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">words</span> = <span class="ruby-node">%w[first second third fourth fifth sixth]</span>
<span class="ruby-identifier">str</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">words</span>.<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">str</span> <span class="ruby-operator">+=</span> <span class="ruby-node">&quot;#{word} &quot;</span>}
<span class="ruby-identifier">p</span> <span class="ruby-identifier">str</span> <span class="ruby-comment">#=&gt; &quot;sixth fifth fourth third second first &quot;</span>
</pre>

<p>The <a href="Array.html#method-i-map"><code>map</code></a> method can be used to create a new array based on the original array, but with the values modified by the supplied block:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-value">2</span><span class="ruby-operator">*</span><span class="ruby-identifier">a</span>}     <span class="ruby-comment">#=&gt; [2, 4, 6, 8, 10]</span>
<span class="ruby-identifier">arr</span>                   <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span><span class="ruby-operator">**</span><span class="ruby-value">2</span>}   <span class="ruby-comment">#=&gt; [1, 4, 9, 16, 25]</span>
<span class="ruby-identifier">arr</span>                   <span class="ruby-comment">#=&gt; [1, 4, 9, 16, 25]</span>
</pre>

<h2 id="class-Array-label-Selecting+Items+from+an+Array">Selecting Items from an <a href="Array.html"><code>Array</code></a><span><a href="#class-Array-label-Selecting+Items+from+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Elements can be selected from an array according to criteria defined in a block.  The selection can happen in a destructive or a non-destructive manner.  While the destructive operations will modify the array they were called on, the non-destructive methods usually return a new array with the selected elements, but leave the original array unchanged.</p>

<h3 id="class-Array-label-Non-destructive+Selection">Non-destructive Selection<span><a href="#class-Array-label-Non-destructive+Selection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>}       <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span>}       <span class="ruby-comment">#=&gt; [3, 4, 5, 6]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">drop_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>                          <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6]</span>
</pre>

<h3 id="class-Array-label-Destructive+Selection">Destructive Selection<span><a href="#class-Array-label-Destructive+Selection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Array.html#method-i-select-21"><code>select!</code></a> and <a href="Array.html#method-i-reject-21"><code>reject!</code></a> are the corresponding destructive methods to <a href="Array.html#method-i-select"><code>select</code></a> and <a href="Array.html#method-i-reject"><code>reject</code></a></p>

<p>Similar to <a href="Array.html#method-i-select"><code>select</code></a> vs. <a href="Array.html#method-i-reject"><code>reject</code></a>, <a href="Array.html#method-i-delete_if"><code>delete_if</code></a> and <a href="Array.html#method-i-keep_if"><code>keep_if</code></a> have the exact opposite result when supplied with the same block:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>                         <span class="ruby-comment">#=&gt; [4, 5, 6]</span>

<span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">keep_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">arr</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<h2 id="class-Array-label-What-27s+Here">What’s Here<span><a href="#class-Array-label-What-27s+Here">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>First, what’s elsewhere. Class <a href="Array.html"><code>Array</code></a>:</p>
<ul><li>
<p>Inherits from <a href="Object.html#class-Object-label-What-27s+Here">class Object</a>.</p>
</li><li>
<p>Includes <a href="Enumerable.html#module-Enumerable-label-What-27s+Here">module Enumerable</a>, which provides dozens of additional methods.</p>
</li></ul>

<p>Here, class <a href="Array.html"><code>Array</code></a> provides methods that are useful for:</p>
<ul><li>
<p><a href="Array.html#class-Array-label-Methods+for+Creating+an+Array">Creating an Array</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Querying">Querying</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Comparing">Comparing</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Fetching">Fetching</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Assigning">Assigning</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Deleting">Deleting</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Combining">Combining</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Iterating">Iterating</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Methods+for+Converting">Converting</a></p>
</li><li>
<p><a href="Array.html#class-Array-label-Other+Methods">And more.…</a></p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an <a href="Array.html"><code>Array</code></a><span><a href="#class-Array-label-Methods+for+Creating+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="Array.html#method-c-5B-5D"><code>::[]</code></a>: Returns a new array populated with given objects.</p>
</li><li>
<p><a href="Array.html#method-c-new"><code>::new</code></a>: Returns a new array.</p>
</li><li>
<p><a href="Array.html#method-c-try_convert"><code>::try_convert</code></a>: Returns a new array created from a given object.</p>
</li></ul>

<p>See also <a href="Array.html#class-Array-label-Creating+Arrays">Creating Arrays</a>.</p>

<h3 id="class-Array-label-Methods+for+Querying">Methods for Querying<span><a href="#class-Array-label-Methods+for+Querying">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="Array.html#method-i-all-3F"><code>all?</code></a>: Returns whether all elements meet a given criterion.</p>
</li><li>
<p><a href="Array.html#method-i-any-3F"><code>any?</code></a>: Returns whether any element meets a given criterion.</p>
</li><li>
<p><a href="Array.html#method-i-count"><code>count</code></a>: Returns the count of elements that meet a given criterion.</p>
</li><li>
<p><a href="Array.html#method-i-empty-3F"><code>empty?</code></a>: Returns whether there are no elements.</p>
</li><li>
<p><a href="Array.html#method-i-find_index"><code>find_index</code></a> (aliased as <a href="Array.html#method-i-index"><code>index</code></a>): Returns the index of the first element that meets a given criterion.</p>
</li><li>
<p><a href="Array.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p>
</li><li>
<p><a href="Array.html#method-i-include-3F"><code>include?</code></a>: Returns whether any element <code>==</code> a given object.</p>
</li><li>
<p><a href="Array.html#method-i-length"><code>length</code></a> (aliased as <a href="Array.html#method-i-size"><code>size</code></a>): Returns the count of elements.</p>
</li><li>
<p><a href="Array.html#method-i-none-3F"><code>none?</code></a>: Returns whether no element <code>==</code> a given object.</p>
</li><li>
<p><a href="Array.html#method-i-one-3F"><code>one?</code></a>: Returns whether exactly one element <code>==</code> a given object.</p>
</li><li>
<p><a href="Array.html#method-i-rindex"><code>rindex</code></a>: Returns the index of the last element that meets a given criterion.</p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Comparing">Methods for Comparing<span><a href="#class-Array-label-Methods+for+Comparing">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>: Returns -1, 0, or 1, as <code>self</code> is less than, equal to, or greater than a given object.</p>
</li><li>
<p><a href="Array.html#method-i-3D-3D"><code>==</code></a>: Returns whether each element in <code>self</code> is <code>==</code> to the corresponding element in a given object.</p>
</li><li>
<p><a href="Array.html#method-i-eql-3F"><code>eql?</code></a>: Returns whether each element in <code>self</code> is <code>eql?</code> to the corresponding element in a given object.</p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Fetching">Methods for Fetching<span><a href="#class-Array-label-Methods+for+Fetching">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>These methods do not modify <code>self</code>.</p>
<ul><li>
<p><a href="Array.html#method-i-5B-5D"><code>[]</code></a> (aliased as <a href="Array.html#method-i-slice"><code>slice</code></a>): Returns consecutive elements as determined by a given argument.</p>
</li><li>
<p><a href="Array.html#method-i-assoc"><code>assoc</code></a>: Returns the first element that is an array whose first element <code>==</code> a given object.</p>
</li><li>
<p><a href="Array.html#method-i-at"><code>at</code></a>: Returns the element at a given offset.</p>
</li><li>
<p><a href="Array.html#method-i-bsearch"><code>bsearch</code></a>: Returns an element selected via a binary search as determined by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-bsearch_index"><code>bsearch_index</code></a>: Returns the index of an element selected via a binary search as determined by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-compact"><code>compact</code></a>: Returns an array containing all non-<code>nil</code> elements.</p>
</li><li>
<p><a href="Array.html#method-i-dig"><code>dig</code></a>: Returns the object in nested objects that is specified by a given index and additional arguments.</p>
</li><li>
<p><a href="Array.html#method-i-drop"><code>drop</code></a>: Returns trailing elements as determined by a given index.</p>
</li><li>
<p><a href="Array.html#method-i-drop_while"><code>drop_while</code></a>: Returns trailing elements as determined by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-fetch"><code>fetch</code></a>: Returns the element at a given offset.</p>
</li><li>
<p><a href="Array.html#method-i-fetch_values"><code>fetch_values</code></a>: Returns elements at given offsets.</p>
</li><li>
<p><a href="Array.html#method-i-first"><code>first</code></a>: Returns one or more leading elements.</p>
</li><li>
<p><a href="Array.html#method-i-last"><code>last</code></a>: Returns one or more trailing elements.</p>
</li><li>
<p><a href="Array.html#method-i-max"><code>max</code></a>: Returns one or more maximum-valued elements, as determined by <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p>
</li><li>
<p><a href="Array.html#method-i-min"><code>min</code></a>: Returns one or more minimum-valued elements, as determined by <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p>
</li><li>
<p><a href="Array.html#method-i-minmax"><code>minmax</code></a>: Returns the minimum-valued and maximum-valued elements, as determined by <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p>
</li><li>
<p><a href="Array.html#method-i-rassoc"><code>rassoc</code></a>: Returns the first element that is an array whose second element <code>==</code> a given object.</p>
</li><li>
<p><a href="Array.html#method-i-reject"><code>reject</code></a>: Returns an array containing elements not rejected by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-reverse"><code>reverse</code></a>: Returns all elements in reverse order.</p>
</li><li>
<p><a href="Array.html#method-i-rotate"><code>rotate</code></a>: Returns all elements with some rotated from one end to the other.</p>
</li><li>
<p><a href="Array.html#method-i-sample"><code>sample</code></a>: Returns one or more random elements.</p>
</li><li>
<p><a href="Array.html#method-i-select"><code>select</code></a> (aliased as <a href="Array.html#method-i-filter"><code>filter</code></a>): Returns an array containing elements selected by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-shuffle"><code>shuffle</code></a>: Returns elements in a random order.</p>
</li><li>
<p><a href="Array.html#method-i-sort"><code>sort</code></a>: Returns all elements in an order determined by <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p>
</li><li>
<p><a href="Array.html#method-i-take"><code>take</code></a>: Returns leading elements as determined by a given index.</p>
</li><li>
<p><a href="Array.html#method-i-take_while"><code>take_while</code></a>: Returns leading elements as determined by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-uniq"><code>uniq</code></a>: Returns an array containing non-duplicate elements.</p>
</li><li>
<p><a href="Array.html#method-i-values_at"><code>values_at</code></a>: Returns the elements at given offsets.</p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Assigning">Methods for Assigning<span><a href="#class-Array-label-Methods+for+Assigning">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>These methods add, replace, or reorder elements in <code>self</code>.</p>
<ul><li>
<p><a href="Array.html#method-i-3C-3C"><code>&lt;&lt;</code></a>: Appends an element.</p>
</li><li>
<p><a href="Array.html#method-i-5B-5D-3D"><code>[]=</code></a>: Assigns specified elements with a given object.</p>
</li><li>
<p><a href="Array.html#method-i-concat"><code>concat</code></a>: Appends all elements from given arrays.</p>
</li><li>
<p><a href="Array.html#method-i-fill"><code>fill</code></a>: Replaces specified elements with specified objects.</p>
</li><li>
<p><a href="Array.html#method-i-flatten-21"><code>flatten!</code></a>: Replaces each nested array in <code>self</code> with the elements from that array.</p>
</li><li>
<p><a href="Array.html#method-i-initialize_copy"><code>initialize_copy</code></a> (aliased as <a href="Array.html#method-i-replace"><code>replace</code></a>): Replaces the content of <code>self</code> with the content of a given array.</p>
</li><li>
<p><a href="Array.html#method-i-insert"><code>insert</code></a>: Inserts given objects at a given offset; does not replace elements.</p>
</li><li>
<p><a href="Array.html#method-i-push"><code>push</code></a> (aliased as <a href="Array.html#method-i-append"><code>append</code></a>): Appends elements.</p>
</li><li>
<p><a href="Array.html#method-i-reverse-21"><code>reverse!</code></a>: Replaces <code>self</code> with its elements reversed.</p>
</li><li>
<p><a href="Array.html#method-i-rotate-21"><code>rotate!</code></a>: Replaces <code>self</code> with its elements rotated.</p>
</li><li>
<p><a href="Array.html#method-i-shuffle-21"><code>shuffle!</code></a>: Replaces <code>self</code> with its elements in random order.</p>
</li><li>
<p><a href="Array.html#method-i-sort-21"><code>sort!</code></a>: Replaces <code>self</code> with its elements sorted, as determined by <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p>
</li><li>
<p><a href="Array.html#method-i-sort_by-21"><code>sort_by!</code></a>: Replaces <code>self</code> with its elements sorted, as determined by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-unshift"><code>unshift</code></a> (aliased as <a href="Array.html#method-i-prepend"><code>prepend</code></a>): Prepends leading elements.</p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Deleting">Methods for Deleting<span><a href="#class-Array-label-Methods+for+Deleting">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Each of these methods removes elements from <code>self</code>:</p>
<ul><li>
<p><a href="Array.html#method-i-clear"><code>clear</code></a>: Removes all elements.</p>
</li><li>
<p><a href="Array.html#method-i-compact-21"><code>compact!</code></a>: Removes all <code>nil</code> elements.</p>
</li><li>
<p><a href="Array.html#method-i-delete"><code>delete</code></a>: Removes elements equal to a given object.</p>
</li><li>
<p><a href="Array.html#method-i-delete_at"><code>delete_at</code></a>: Removes the element at a given offset.</p>
</li><li>
<p><a href="Array.html#method-i-delete_if"><code>delete_if</code></a>: Removes elements specified by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-keep_if"><code>keep_if</code></a>: Removes elements not specified by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-pop"><code>pop</code></a>: Removes and returns the last element.</p>
</li><li>
<p><a href="Array.html#method-i-reject-21"><code>reject!</code></a>: Removes elements specified by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-select-21"><code>select!</code></a> (aliased as <a href="Array.html#method-i-filter-21"><code>filter!</code></a>): Removes elements not specified by a given block.</p>
</li><li>
<p><a href="Array.html#method-i-shift"><code>shift</code></a>:  Removes and returns the first element.</p>
</li><li>
<p><a href="Array.html#method-i-slice-21"><code>slice!</code></a>: Removes and returns a sequence of elements.</p>
</li><li>
<p><a href="Array.html#method-i-uniq-21"><code>uniq!</code></a>: Removes duplicates.</p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Combining">Methods for Combining<span><a href="#class-Array-label-Methods+for+Combining">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="Array.html#method-i-26"><code>&amp;</code></a>: Returns an array containing elements found both in <code>self</code> and a given array.</p>
</li><li>
<p><a href="Array.html#method-i-2B"><code>+</code></a>: Returns an array containing all elements of <code>self</code> followed by all elements of a given array.</p>
</li><li>
<p><a href="Array.html#method-i-2D"><code>-</code></a>: Returns an array containing all elements of <code>self</code> that are not found in a given array.</p>
</li><li>
<p><a href="Array.html#method-i-7C"><code>|</code></a>: Returns an array containing all element of <code>self</code> and all elements of a given array, duplicates removed.</p>
</li><li>
<p><a href="Array.html#method-i-difference"><code>difference</code></a>: Returns an array containing all elements of <code>self</code> that are not found in any of the given arrays..</p>
</li><li>
<p><a href="Array.html#method-i-intersection"><code>intersection</code></a>: Returns an array containing elements found both in <code>self</code> and in each given array.</p>
</li><li>
<p><a href="Array.html#method-i-product"><code>product</code></a>: Returns or yields all combinations of elements from <code>self</code> and given arrays.</p>
</li><li>
<p><a href="Array.html#method-i-reverse"><code>reverse</code></a>: Returns an array containing all elements of <code>self</code> in reverse order.</p>
</li><li>
<p><a href="Array.html#method-i-union"><code>union</code></a>: Returns an array containing all elements of <code>self</code> and all elements of given arrays, duplicates removed.</p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Iterating">Methods for Iterating<span><a href="#class-Array-label-Methods+for+Iterating">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="Array.html#method-i-combination"><code>combination</code></a>: Calls a given block with combinations of elements of <code>self</code>; a combination does not use the same element more than once.</p>
</li><li>
<p><a href="Array.html#method-i-cycle"><code>cycle</code></a>: Calls a given block with each element, then does so again, for a specified number of times, or forever.</p>
</li><li>
<p><a href="Array.html#method-i-each"><code>each</code></a>: Passes each element to a given block.</p>
</li><li>
<p><a href="Array.html#method-i-each_index"><code>each_index</code></a>: Passes each element index to a given block.</p>
</li><li>
<p><a href="Array.html#method-i-permutation"><code>permutation</code></a>: Calls a given block with permutations of elements of <code>self</code>; a permutation does not use the same element more than once.</p>
</li><li>
<p><a href="Array.html#method-i-repeated_combination"><code>repeated_combination</code></a>: Calls a given block with combinations of elements of <code>self</code>; a combination may use the same element more than once.</p>
</li><li>
<p><a href="Array.html#method-i-repeated_permutation"><code>repeated_permutation</code></a>: Calls a given block with permutations of elements of <code>self</code>; a permutation may use the same element more than once.</p>
</li><li>
<p><a href="Array.html#method-i-reverse_each"><code>reverse_each</code></a>:  Passes each element, in reverse order, to a given block.</p>
</li></ul>

<h3 id="class-Array-label-Methods+for+Converting">Methods for Converting<span><a href="#class-Array-label-Methods+for+Converting">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="Array.html#method-i-collect"><code>collect</code></a> (aliased as <a href="Array.html#method-i-map"><code>map</code></a>): Returns an array containing the block return-value for each element.</p>
</li><li>
<p><a href="Array.html#method-i-collect-21"><code>collect!</code></a> (aliased as <a href="Array.html#method-i-map-21"><code>map!</code></a>): Replaces each element with a block return-value.</p>
</li><li>
<p><a href="Array.html#method-i-flatten"><code>flatten</code></a>: Returns an array that is a recursive flattening of <code>self</code>.</p>
</li><li>
<p><a href="Array.html#method-i-inspect"><code>inspect</code></a> (aliased as <a href="Array.html#method-i-to_s"><code>to_s</code></a>): Returns a new <a href="String.html"><code>String</code></a> containing the elements.</p>
</li><li>
<p><a href="Array.html#method-i-join"><code>join</code></a>: Returns a newsString containing the elements joined by the field separator.</p>
</li><li>
<p><a href="Array.html#method-i-to_a"><code>to_a</code></a>: Returns <code>self</code> or a new array containing all elements.</p>
</li><li>
<p><a href="Array.html#method-i-to_ary"><code>to_ary</code></a>: Returns <code>self</code>.</p>
</li><li>
<p><a href="Array.html#method-i-to_h"><code>to_h</code></a>: Returns a new hash formed from the elements.</p>
</li><li>
<p><a href="Array.html#method-i-transpose"><code>transpose</code></a>: Transposes <code>self</code>, which must be an array of arrays.</p>
</li><li>
<p><a href="Array.html#method-i-zip"><code>zip</code></a>: Returns a new array of arrays containing <code>self</code> and given arrays.</p>
</li></ul>

<h3 id="class-Array-label-Other+Methods">Other Methods<span><a href="#class-Array-label-Other+Methods">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="Array.html#method-i-2A"><code>*</code></a>: Returns one of the following:</p>
<ul><li>
<p>With integer argument <code>n</code>, a new array that is the concatenation of <code>n</code> copies of <code>self</code>.</p>
</li><li>
<p>With string argument <code>field_separator</code>, a new string that is equivalent to <code>join(field_separator)</code>.</p>
</li></ul>
</li><li>
<p><a href="Array.html#method-i-pack"><code>pack</code></a>: Packs the elements into a binary sequence.</p>
</li><li>
<p><a href="Array.html#method-i-sum"><code>sum</code></a>: Returns a sum of elements according to either <code>+</code> or a given block.</p>
</li></ul>

  </section>

  <section id="5Buntitled-5D" class="documentation-section anchor-link">





     <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-5B-5D" class="method-detail anchor-link ">
        <div class="method-header">
            <div class="method-heading">
              <a href="#method-c-5B-5D" title="Link to this method">
                <span class="method-name">[]</span>
                <span class="method-args">(*args)</span>
              </a>
            </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE
rb_ary_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE ary = ary_new(klass, argc);
    if (argc &gt; 0 &amp;&amp; argv) {
        ary_memcpy(ary, 0, argc, argv);
        ARY_SET_LEN(ary, argc);
    }

    return ary;
}</pre>
          </div>
          <p>Returns a new array, populated with the given objects:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>[<span class="ruby-value">1</span>, <span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-regexp">/^A/</span>]    <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
<span class="ruby-constant">Array</span>[]                <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">[]</span>(<span class="ruby-value">1</span>, <span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-regexp">/^A/</span>) <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an Array</a>.</p>
        </div>


      </div>

      <div id="method-c-new" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-c-new" title="Link to this method">
                  <span class="method-callseq">
                    new &rarr; new_empty_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-c-new" title="Link to this method">
                  <span class="method-callseq">
                    new(array) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-c-new" title="Link to this method">
                  <span class="method-callseq">
                    new(size, default_value = nil) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-c-new" title="Link to this method">
                  <span class="method-callseq">
                    new(size = 0) {|index| ... } &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="new-source">
            <pre>static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
        rb_ary_reset(ary);
        RUBY_ASSERT(ARY_EMBED_P(ary));
        RUBY_ASSERT(ARY_EMBED_LEN(ary) == 0);
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        return ary;
    }
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    /* NUM2LONG() may call size.to_int, ary can be frozen, modified, etc */
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    /* recheck after argument conversion */
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn(&quot;block supersedes default value argument&quot;);
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            ARY_SET_LEN(ary, i + 1);
        }
    }
    else {
        ary_memfill(ary, 0, len, val);
        ARY_SET_LEN(ary, len);
    }
    return ary;
}</pre>
          </div>
          <p>Returns a new array.</p>

<p>With no block and no argument given, returns a new empty array:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span> <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>With no block and array argument given, returns a new array with the same elements:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>With no block and integer argument given, returns a new array containing that many instances of the given <code>default_value</code>:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">0</span>)    <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)    <span class="ruby-comment"># =&gt; [nil, nil, nil]</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [3, 3]</span>
</pre>

<p>With a block given, returns an array of the given <code>size</code>; calls the block with each <code>index</code> in the range <code>(0...size)</code>; the element at that <code>index</code> in the returned array is the blocks return value:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)  {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Element #{index}&quot;</span> } <span class="ruby-comment"># =&gt; [&quot;Element 0&quot;, &quot;Element 1&quot;, &quot;Element 2&quot;]</span>
</pre>

<p>A common pitfall for new Rubyists is providing an expression as <code>default_value</code>:</p>

<pre class="ruby"><span class="ruby-identifier">array</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, {})
<span class="ruby-identifier">array</span> <span class="ruby-comment"># =&gt; [{}, {}]</span>
<span class="ruby-identifier">array</span>[<span class="ruby-value">0</span>][<span class="ruby-value">:a</span>] = <span class="ruby-value">1</span>
<span class="ruby-identifier">array</span> <span class="ruby-comment"># =&gt; [{a: 1}, {a: 1}], as array[0] and array[1] are same object</span>
</pre>

<p>If you want the elements of the array to be distinct, you should pass a block:</p>

<pre class="ruby"><span class="ruby-identifier">array</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>) { {} }
<span class="ruby-identifier">array</span> <span class="ruby-comment"># =&gt; [{}, {}]</span>
<span class="ruby-identifier">array</span>[<span class="ruby-value">0</span>][<span class="ruby-value">:a</span>] = <span class="ruby-value">1</span>
<span class="ruby-identifier">array</span> <span class="ruby-comment"># =&gt; [{a: 1}, {}], as array[0] and array[1] are different objects</span>
</pre>

<p>Raises <a href="TypeError.html"><code>TypeError</code></a> if the first argument is not either an array or an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>). Raises <a href="ArgumentError.html"><code>ArgumentError</code></a> if the first argument is a negative integer.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an Array</a>.</p>
        </div>


      </div>

      <div id="method-c-try_convert" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-c-try_convert" title="Link to this method">
                  <span class="method-callseq">
                    try_convert(object) &rarr; object, new_array, or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="try_convert-source">
            <pre>static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}</pre>
          </div>
          <p>Attempts to return an array, based on the given <code>object</code>.</p>

<p>If <code>object</code> is an array, returns <code>object</code>.</p>

<p>Otherwise if <code>object</code> responds to <code>:to_ary</code>. calls <code>object.to_ary</code>: if the return value is an array or <code>nil</code>, returns that value; if not, raises <a href="TypeError.html"><code>TypeError</code></a>.</p>

<p>Otherwise returns <code>nil</code>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an Array</a>.</p>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-26" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-26" title="Link to this method">
                  <span class="method-callseq">
                    self &amp; other_array &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="26-source">
            <pre>static VALUE
rb_ary_and(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3, v;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
    if (RARRAY_LEN(ary1) == 0 || RARRAY_LEN(ary2) == 0) return ary3;

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            v = RARRAY_AREF(ary1, i);
            if (!rb_ary_includes_by_eql(ary2, v)) continue;
            if (rb_ary_includes_by_eql(ary3, v)) continue;
            rb_ary_push(ary3, v);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        v = RARRAY_AREF(ary1, i);
        vv = (st_data_t)v;
        if (rb_hash_stlike_delete(hash, &amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }

    return ary3;
}</pre>
          </div>
          <p>Returns a new array containing the <em>intersection</em> of <code>self</code> and <code>other_array</code>; that is, containing those elements found in both <code>self</code> and <code>other_array</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-operator">&amp;</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [1, 2]</span>
</pre>

<p>Omits duplicates:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>] <span class="ruby-operator">&amp;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; [0, 1]</span>
</pre>

<p>Preserves order from <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&amp;</span> [<span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Identifies common elements using method <a href="Array.html#method-i-eql-3F"><code>eql?</code></a> (as defined in each element of <code>self</code>).</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-2A" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-2A" title="Link to this method">
                  <span class="method-callseq">
                    self * n &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-2A" title="Link to this method">
                  <span class="method-callseq">
                    self * string_separator &rarr; new_string
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="2A-source">
            <pre>static VALUE
rb_ary_times(VALUE ary, VALUE times)
{
    VALUE ary2, tmp;
    const VALUE *ptr;
    long t, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
        return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) {
        ary2 = ary_new(rb_cArray, 0);
        goto out;
    }
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY_LEN(ary)) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    len *= RARRAY_LEN(ary);

    ary2 = ary_new(rb_cArray, len);
    ARY_SET_LEN(ary2, len);

    ptr = RARRAY_CONST_PTR(ary);
    t = RARRAY_LEN(ary);
    if (0 &lt; t) {
        ary_memcpy(ary2, 0, t, ptr);
        while (t &lt;= len/2) {
            ary_memcpy(ary2, t, t, RARRAY_CONST_PTR(ary2));
            t *= 2;
        }
        if (t &lt; len) {
            ary_memcpy(ary2, t, len-t, RARRAY_CONST_PTR(ary2));
        }
    }
  out:
    return ary2;
}</pre>
          </div>
          <p>When non-negative integer argument <code>n</code> is given, returns a new array built by concatenating <code>n</code> copies of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;x&#39;</span>, <span class="ruby-string">&#39;y&#39;</span>]
<span class="ruby-identifier">a</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span> <span class="ruby-comment"># =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;x&quot;, &quot;y&quot;, &quot;x&quot;, &quot;y&quot;]</span>
</pre>

<p>When string argument <code>string_separator</code> is given, equivalent to <code>self.join(string_separator)</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}] <span class="ruby-operator">*</span> <span class="ruby-string">&#39;, &#39;</span> <span class="ruby-comment"># =&gt; &quot;0, 0, 1, {foo: 0}&quot;</span>
</pre>
        </div>


      </div>

      <div id="method-i-2B" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-2B" title="Link to this method">
                  <span class="method-callseq">
                    self + other_array &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="2B-source">
            <pre>VALUE
rb_ary_plus(VALUE x, VALUE y)
{
    VALUE z;
    long len, xlen, ylen;

    y = to_ary(y);
    xlen = RARRAY_LEN(x);
    ylen = RARRAY_LEN(y);
    len = xlen + ylen;
    z = rb_ary_new2(len);

    ary_memcpy(z, 0, xlen, RARRAY_CONST_PTR(x));
    ary_memcpy(z, xlen, ylen, RARRAY_CONST_PTR(y));
    ARY_SET_LEN(z, len);
    return z;
}</pre>
          </div>
          <p>Returns a new array containing all elements of <code>self</code> followed by all elements of <code>other_array</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">+</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-2D" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-2D" title="Link to this method">
                  <span class="method-callseq">
                    self - other_array &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="2D-source">
            <pre>VALUE
rb_ary_diff(VALUE ary1, VALUE ary2)
{
    VALUE ary3;
    VALUE hash;
    long i;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary2) == 0) { return ary_make_shared_copy(ary1); }
    ary3 = rb_ary_new();

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN || RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            VALUE elt = rb_ary_elt(ary1, i);
            if (rb_ary_includes_by_eql(ary2, elt)) continue;
            rb_ary_push(ary3, elt);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);
    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        if (rb_hash_stlike_lookup(hash, RARRAY_AREF(ary1, i), NULL)) continue;
        rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }

    return ary3;
}</pre>
          </div>
          <p>Returns a new array containing only those elements of <code>self</code> that are not found in <code>other_array</code>; the order from <code>self</code> is preserved:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">-</span> [<span class="ruby-value">1</span>]             <span class="ruby-comment"># =&gt; [0, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">-</span> [<span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">:foo</span>] <span class="ruby-comment"># =&gt; [1, 1, 1, 1, 1, 1]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">-</span> [<span class="ruby-value">:foo</span>]                            <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Element are compared using method <a href="Array.html#method-i-eql-3F"><code>eql?</code></a> (as defined in each element of <code>self</code>).</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-3C-3C" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-3C-3C" title="Link to this method">
                  <span class="method-callseq">
                    self &lt;&lt; object &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="3C-3C-source">
            <pre>VALUE
rb_ary_push(VALUE ary, VALUE item)
{
    long idx = RARRAY_LEN((ary_verify(ary), ary));
    VALUE target_ary = ary_ensure_room_for_push(ary, 1);
    RARRAY_PTR_USE(ary, ptr, {
        RB_OBJ_WRITE(target_ary, &amp;ptr[idx], item);
    });
    ARY_SET_LEN(ary, idx + 1);
    ary_verify(ary);
    return ary;
}</pre>
          </div>
          <p>Appends <code>object</code> as the last element in <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:baz</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, :baz]</span>
</pre>

<p>Appends <code>object</code> as a single element, even if it is another array:</p>

<pre class="ruby">[<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, [3, 4]]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-3C-3D-3E" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-3C-3D-3E" title="Link to this method">
                  <span class="method-callseq">
                    self &lt;=&gt; other_array &rarr; -1, 0, or 1
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="3C-3D-3E-source">
            <pre>VALUE
rb_ary_cmp(VALUE ary1, VALUE ary2)
{
    long len;
    VALUE v;

    ary2 = rb_check_array_type(ary2);
    if (NIL_P(ary2)) return Qnil;
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2);
    if (!UNDEF_P(v)) return v;
    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}</pre>
          </div>
          <p>Returns -1, 0, or 1 as <code>self</code> is determined to be less than, equal to, or greater than <code>other_array</code>.</p>

<p>Iterates over each index <code>i</code> in <code>(0...self.size)</code>:</p>
<ul><li>
<p>Computes <code>result[i]</code> as <code>self[i] &lt;=&gt; other_array[i]</code>.</p>
</li><li>
<p>Immediately returns 1 if <code>result[i]</code> is 1:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; 1</span>
</pre>
</li><li>
<p>Immediately returns -1 if <code>result[i]</code> is -1:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; -1</span>
</pre>
</li><li>
<p>Continues if <code>result[i]</code> is 0.</p>
</li></ul>

<p>When every <code>result</code> is 0, returns <code>self.size &lt;=&gt; other_array.size</code> (see <a href="Integer.html#method-i-3C-3D-3E"><code>Integer#&lt;=&gt;</code></a>):</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]        <span class="ruby-comment"># =&gt; 1</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]     <span class="ruby-comment"># =&gt; 0</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]  <span class="ruby-comment"># =&gt; -1</span>
</pre>

<p>Note that when <code>other_array</code> is larger than <code>self</code>, its trailing elements do not affect the result:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">-3</span>] <span class="ruby-comment"># =&gt; -1</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>]  <span class="ruby-comment"># =&gt; -1</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">&lt;=&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]  <span class="ruby-comment"># =&gt; -1</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Comparing">Methods for Comparing</a>.</p>
        </div>


      </div>

      <div id="method-i-3D-3D" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-3D-3D" title="Link to this method">
                  <span class="method-callseq">
                    self == other_array &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE
rb_ary_equal(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) {
        if (!rb_respond_to(ary2, idTo_ary)) {
            return Qfalse;
        }
        return rb_equal(ary2, ary1);
    }
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_equal, ary1, ary2, ary2);
}</pre>
          </div>
          <p>Returns whether both:</p>
<ul><li>
<p><code>self</code> and <code>other_array</code> are the same size.</p>
</li><li>
<p>Their corresponding elements are the same; that is, for each index <code>i</code> in <code>(0...self.size)</code>, <code>self[i] == other_array[i]</code>.</p>
</li></ul>

<p>Examples:</p>

<pre class="ruby">[<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">==</span> [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]   <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">==</span> [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2.0</span>] <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">==</span> [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>]      <span class="ruby-comment"># =&gt; false # Different sizes.</span>
[<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">==</span> [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">3</span>]   <span class="ruby-comment"># =&gt; false # Different elements.</span>
</pre>

<p>This method is different from method <a href="Array.html#method-i-eql-3F"><code>Array#eql?</code></a>, which compares elements using <a href="Object.html#method-i-eql-3F"><code>Object#eql?</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Comparing">Methods for Comparing</a>.</p>
        </div>


      </div>

      <div id="method-i-5B-5D" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-5B-5D" title="Link to this method">
                  <span class="method-callseq">
                    self[index] &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-5B-5D" title="Link to this method">
                  <span class="method-callseq">
                    self[start, length] &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-5B-5D" title="Link to this method">
                  <span class="method-callseq">
                    self[range] &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-5B-5D" title="Link to this method">
                  <span class="method-callseq">
                    self[aseq] &rarr; object or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="5B-5D-source">
            <pre>VALUE
rb_ary_aref(int argc, const VALUE *argv, VALUE ary)
{
    rb_check_arity(argc, 1, 2);
    if (argc == 2) {
        return rb_ary_aref2(ary, argv[0], argv[1]);
    }
    return rb_ary_aref1(ary, argv[0]);
}</pre>
          </div>
          <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p>

<p>In brief:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]

<span class="ruby-comment"># Single argument index: returns one element.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>]     <span class="ruby-comment"># =&gt; :foo          # Zero-based index.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>]    <span class="ruby-comment"># =&gt; 2             # Negative index counts backwards from end.</span>

<span class="ruby-comment"># Arguments start and length: returns an array.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]  <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]    # Negative start counts backwards from end.</span>

<span class="ruby-comment"># Single argument range: returns an array.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>]  <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;] # Negative range-begin counts backwards from end.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]    # Negative range-end counts backwards from end.</span>
</pre>

<p>When a single integer argument <code>index</code> is given, returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>index</code> is negative, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>If <code>index</code> is out of range, returns <code>nil</code>.</p>

<p>When two <a href="Integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given, returns a new <a href="Array.html"><code>Array</code></a> of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">4</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
</pre>

<p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty <a href="Array.html"><code>Array</code></a>.</p>

<p>If <code>length</code> is negative, returns <code>nil</code>.</p>

<p>When a single <a href="Range.html"><code>Range</code></a> argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>Special case: If <code>range.start == a.size</code>, returns a new empty <a href="Array.html"><code>Array</code></a>.</p>

<p>If <code>range.end</code> is negative, calculates the end index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] <span class="ruby-comment"># =&gt; [:foo]</span>
</pre>

<p>If <code>range.start</code> is negative, calculates the start index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>When a single <a href="Enumerator/ArithmeticSequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an <a href="Array.html"><code>Array</code></a> of elements corresponding to the indexes produced by the sequence.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)] <span class="ruby-comment"># =&gt; [&quot;data1&quot;, &quot;data2&quot;, &quot;data3&quot;]</span>
</pre>

<p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="RangeError.html"><code>RangeError</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">11</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((1..11).step(2)) out of range)</span>
<span class="ruby-identifier">a</span>[(<span class="ruby-value">7</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((7..).step(2)) out of range)</span>
</pre>

<p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="Integer.html"><code>Integer</code></a>, and raises if it is impossible:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-comment"># Raises TypeError (no implicit conversion of Symbol into Integer):</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">:foo</span>]
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-slice">slice</a>
        </div>

      </div>

      <div id="method-i-5B-5D-3D" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-5B-5D-3D" title="Link to this method">
                  <span class="method-callseq">
                    self[index] = object &rarr; object
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-5B-5D-3D" title="Link to this method">
                  <span class="method-callseq">
                    self[start, length] = object &rarr; object
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-5B-5D-3D" title="Link to this method">
                  <span class="method-callseq">
                    self[range] = object &rarr; object
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE
rb_ary_aset(int argc, VALUE *argv, VALUE ary)
{
    long offset, beg, len;

    rb_check_arity(argc, 2, 3);
    rb_ary_modify_check(ary);
    if (argc == 3) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[2]);
    }
    if (FIXNUM_P(argv[0])) {
        offset = FIX2LONG(argv[0]);
        return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
        /* check if idx is Range */
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[1]);
    }

    offset = NUM2LONG(argv[0]);
    return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
}</pre>
          </div>
          <p>Assigns elements in <code>self</code>, based on the given <code>object</code>; returns <code>object</code>.</p>

<p>In brief:</p>

<pre class="ruby"><span class="ruby-identifier">a_orig</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]

<span class="ruby-comment"># With argument index.</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">a_orig</span>.<span class="ruby-identifier">dup</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">a_orig</span>.<span class="ruby-identifier">dup</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">7</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, nil, &quot;foo&quot;]</span>

<span class="ruby-comment"># With arguments start and length.</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">a_orig</span>.<span class="ruby-identifier">dup</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, 2]</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">a_orig</span>.<span class="ruby-identifier">dup</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>, <span class="ruby-value">50</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, &quot;foo&quot;]</span>

<span class="ruby-comment"># With argument range.</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">a_orig</span>.<span class="ruby-identifier">dup</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, 2]</span>
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">a_orig</span>.<span class="ruby-identifier">dup</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span><span class="ruby-operator">..</span><span class="ruby-value">50</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, &quot;foo&quot;]</span>
</pre>

<p>When <a href="Integer.html"><code>Integer</code></a> argument <code>index</code> is given, assigns <code>object</code> to an element in <code>self</code>.</p>

<p>If <code>index</code> is non-negative, assigns <code>object</code> the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>index</code> is greater than <code>self.length</code>, extends the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">7</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, nil, &quot;foo&quot;]</span>
</pre>

<p>If <code>index</code> is negative, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>] = <span class="ruby-string">&#39;two&#39;</span> <span class="ruby-comment"># =&gt; &quot;two&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, &quot;two&quot;]</span>
</pre>

<p>When <a href="Integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given and <code>object</code> is not an <a href="Array.html"><code>Array</code></a>, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, 2]</span>
</pre>

<p>If <code>start</code> is negative, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

<p>If <code>start</code> is non-negative and outside the array (<code> &gt;= self.size</code>), extends the array with <code>nil</code>, assigns <code>object</code> at offset <code>start</code>, and ignores <code>length</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>, <span class="ruby-value">50</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, &quot;foo&quot;]</span>
</pre>

<p>If <code>length</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>length</code> is too large for the existing array, does not extend the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">5</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

<p>When <a href="Range.html"><code>Range</code></a> argument <code>range</code> is given and <code>object</code> is not an <a href="Array.html"><code>Array</code></a>, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, 2]</span>
</pre>

<p>if <code>range.begin</code> is negative, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

<p>If the array length is less than <code>range.begin</code>, extends the array with <code>nil</code>, assigns <code>object</code> at offset <code>range.begin</code>, and ignores <code>length</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span><span class="ruby-operator">..</span><span class="ruby-value">50</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, nil, nil, nil, &quot;foo&quot;]</span>
</pre>

<p>If <code>range.end</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>range.end</code> is negative, assigns <code>object</code> at offset <code>start</code>, retains <code>range.end.abs -1</code> elements past that, and removes those beyond:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, 2]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
</pre>

<p>If <code>range.end</code> is too large for the existing array, replaces array elements, but does not extend the array with <code>nil</code> values:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>] = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;foo&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-7C" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-7C" title="Link to this method">
                  <span class="method-callseq">
                    self | other_array &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="7C-source">
            <pre>static VALUE
rb_ary_or(VALUE ary1, VALUE ary2)
{
    VALUE hash;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary1) + RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        VALUE ary3 = rb_ary_new();
        rb_ary_union(ary3, ary1);
        rb_ary_union(ary3, ary2);
        return ary3;
    }

    hash = ary_make_hash(ary1);
    rb_ary_union_hash(hash, ary2);

    return rb_hash_values(hash);
}</pre>
          </div>
          <p>Returns the union of <code>self</code> and <code>other_array</code>; duplicates are removed; order is preserved; items are compared using <code>eql?</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">|</span> [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>] <span class="ruby-operator">|</span> [<span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-operator">|</span> [<span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-all-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-all-3F" title="Link to this method">
                  <span class="method-callseq">
                    all? &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-all-3F" title="Link to this method">
                  <span class="method-callseq">
                    all?(object) &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-all-3F" title="Link to this method">
                  <span class="method-callseq">
                    all? {|element| ... } &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="all-3F-source">
            <pre>static VALUE
rb_ary_all_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (!RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre>
          </div>
          <p>Returns whether for every element of <code>self</code>, a given criterion is satisfied.</p>

<p>With no block and no argument, returns whether every element of <code>self</code> is truthy:</p>

<pre class="ruby">[[], {}, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-constant">Object</span>.<span class="ruby-identifier">new</span>].<span class="ruby-identifier">all?</span> <span class="ruby-comment"># =&gt; true  # All truthy objects.</span>
[[], {}, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-keyword">nil</span>].<span class="ruby-identifier">all?</span>        <span class="ruby-comment"># =&gt; false # nil is not truthy.</span>
[[], {}, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">all?</span>      <span class="ruby-comment"># =&gt; false # false is not truthy.</span>
</pre>

<p>With argument <code>object</code> given, returns whether <code>object === ele</code> for every element <code>ele</code> in <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-value">0</span>)                    <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-value">1</span>)                    <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;fool&#39;</span>, <span class="ruby-string">&#39;foot&#39;</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">all?</span>(<span class="ruby-regexp">/foo/</span>)        <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With a block given, calls the block with each element in <code>self</code>; returns whether the block returns only truthy values:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ele</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ele</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ele</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ele</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With both a block and argument <code>object</code> given, ignores the block and uses <code>object</code> as above.</p>

<p><strong>Special case</strong>: returns <code>true</code> if <code>self</code> is empty (regardless of any given argument or block).</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-any-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-any-3F" title="Link to this method">
                  <span class="method-callseq">
                    any? &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-any-3F" title="Link to this method">
                  <span class="method-callseq">
                    any?(object) &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-any-3F" title="Link to this method">
                  <span class="method-callseq">
                    any? {|element| ... } &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="any-3F-source">
            <pre>static VALUE
rb_ary_any_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qtrue;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    return Qfalse;
}</pre>
          </div>
          <p>Returns whether for any element of <code>self</code>, a given criterion is satisfied.</p>

<p>With no block and no argument, returns whether any element of <code>self</code> is truthy:</p>

<pre class="ruby">[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, []].<span class="ruby-identifier">any?</span> <span class="ruby-comment"># =&gt; true  # Array object is truthy.</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, {}].<span class="ruby-identifier">any?</span> <span class="ruby-comment"># =&gt; true  # Hash object is truthy.</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-string">&#39;&#39;</span>].<span class="ruby-identifier">any?</span> <span class="ruby-comment"># =&gt; true  # String object is truthy.</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">any?</span>     <span class="ruby-comment"># =&gt; false # Nil and false are not truthy.</span>
</pre>

<p>With argument <code>object</code> given, returns whether <code>object === ele</code> for any element <code>ele</code> in <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-value">0</span>)          <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-value">0</span>)          <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-string">&#39;food&#39;</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-string">&#39;food&#39;</span>].<span class="ruby-identifier">any?</span>(<span class="ruby-regexp">/bar/</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With a block given, calls the block with each element in <code>self</code>; returns whether the block returns any truthy value:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ele</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ele</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">1</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ele</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ele</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With both a block and argument <code>object</code> given, ignores the block and uses <code>object</code> as above.</p>

<p><strong>Special case</strong>: returns <code>false</code> if <code>self</code> is empty (regardless of any given argument or block).</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-append" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-append" title="Link to this method">
                  <span class="method-callseq">
                    append(*objects) &rarr; self
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>Appends each argument in <code>objects</code> to <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>)   <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, :baz, :bat]</span>
</pre>

<p>Appends each argument as a single element, even if it is another array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]               <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>([<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>], [<span class="ruby-value">:bam</span>, <span class="ruby-value">:bad</span>]) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, [:baz, :bat], [:bam, :bad]]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-push">push</a>
        </div>
      </div>

      <div id="method-i-assoc" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-assoc" title="Link to this method">
                  <span class="method-callseq">
                    assoc(object) &rarr; found_array or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="assoc-source">
            <pre>VALUE
rb_ary_assoc(VALUE ary, VALUE key)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (!NIL_P(v) &amp;&amp; RARRAY_LEN(v) &gt; 0 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 0), key))
            return v;
    }
    return Qnil;
}</pre>
          </div>
          <p>Returns the first element <code>ele</code> in <code>self</code> such that <code>ele</code> is an array and <code>ele[0] == object</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}, [<span class="ruby-value">2</span>, <span class="ruby-value">4</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; [4, 5, 6]</span>
</pre>

<p>Returns <code>nil</code> if no such element is found.</p>

<p>Related: <a href="Array.html#method-i-rassoc"><code>Array#rassoc</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-at" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-at" title="Link to this method">
                  <span class="method-callseq">
                    at(index) &rarr; object or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="at-source">
            <pre>VALUE
rb_ary_at(VALUE ary, VALUE pos)
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}</pre>
          </div>
          <p>Returns the element of <code>self</code> specified by the given <code>index</code> or <code>nil</code> if there is no such element; <code>index</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>.</p>

<p>For non-negative <code>index</code>, returns the element of <code>self</code> at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">2.0</span>) <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>For negative <code>index</code>, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>Related: <a href="Array.html#method-i-5B-5D"><code>Array#[]</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-bsearch" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-bsearch" title="Link to this method">
                  <span class="method-callseq">
                    bsearch {|element| ... } &rarr; found_element or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-bsearch" title="Link to this method">
                  <span class="method-callseq">
                    bsearch &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="bsearch-source">
            <pre>static VALUE
rb_ary_bsearch(VALUE ary)
{
    VALUE index_result = rb_ary_bsearch_index(ary);

    if (FIXNUM_P(index_result)) {
        return rb_ary_entry(ary, FIX2LONG(index_result));
    }
    return index_result;
}</pre>
          </div>
          <p>Returns the element from <code>self</code> found by a binary search, or <code>nil</code> if the search found no suitable element.</p>

<p>See <a href="bsearch_rdoc.html">Binary Searching</a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-bsearch_index" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-bsearch_index" title="Link to this method">
                  <span class="method-callseq">
                    bsearch_index {|element| ... } &rarr; integer or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-bsearch_index" title="Link to this method">
                  <span class="method-callseq">
                    bsearch_index &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="bsearch_index-source">
            <pre>static VALUE
rb_ary_bsearch_index(VALUE ary)
{
    long low = 0, high = RARRAY_LEN(ary), mid;
    int smaller = 0, satisfied = 0;
    VALUE v, val;

    RETURN_ENUMERATOR(ary, 0, 0);
    while (low &lt; high) {
        mid = low + ((high - low) / 2);
        val = rb_ary_entry(ary, mid);
        v = rb_yield(val);
        if (FIXNUM_P(v)) {
            if (v == INT2FIX(0)) return INT2FIX(mid);
            smaller = (SIGNED_VALUE)v &lt; 0; /* Fixnum preserves its sign-bit */
        }
        else if (v == Qtrue) {
            satisfied = 1;
            smaller = 1;
        }
        else if (!RTEST(v)) {
            smaller = 0;
        }
        else if (rb_obj_is_kind_of(v, rb_cNumeric)) {
            const VALUE zero = INT2FIX(0);
            switch (rb_cmpint(rb_funcallv(v, id_cmp, 1, &amp;zero), v, zero)) {
              case 0: return INT2FIX(mid);
              case 1: smaller = 0; break;
              case -1: smaller = 1;
            }
        }
        else {
            rb_raise(rb_eTypeError, &quot;wrong argument type %&quot;PRIsVALUE
                     &quot; (must be numeric, true, false or nil)&quot;,
                     rb_obj_class(v));
        }
        if (smaller) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    if (!satisfied) return Qnil;
    return INT2FIX(low);
}</pre>
          </div>
          <p>Returns the integer index of the element from <code>self</code> found by a binary search, or <code>nil</code> if the search found no suitable element.</p>

<p>See <a href="bsearch_rdoc.html">Binary Searching</a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-clear" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-clear" title="Link to this method">
                  <span class="method-callseq">
                    clear &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="clear-source">
            <pre>VALUE
rb_ary_clear(VALUE ary)
{
    rb_ary_modify_check(ary);
    if (ARY_SHARED_P(ary)) {
        rb_ary_unshare(ary);
        FL_SET_EMBED(ary);
        ARY_SET_EMBED_LEN(ary, 0);
    }
    else {
        ARY_SET_LEN(ary, 0);
        if (ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
            ary_resize_capa(ary, ARY_DEFAULT_SIZE * 2);
        }
    }
    ary_verify(ary);
    return ary;
}</pre>
          </div>
          <p>Removes all elements from <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-collect" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-collect" title="Link to this method">
                  <span class="method-callseq">
                    collect {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-collect" title="Link to this method">
                  <span class="method-callseq">
                    collect &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="collect-source">
            <pre>static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_push(collect, rb_yield(RARRAY_AREF(ary, i)));
    }
    return collect;
}</pre>
          </div>
          <p>With a block given, calls the block with each element of <code>self</code>; returns a new array whose elements are the return values from the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: <a href="Array.html#method-i-collect-21"><code>collect!</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-map">map</a>
        </div>

      </div>

      <div id="method-i-collect-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-collect-21" title="Link to this method">
                  <span class="method-callseq">
                    collect! {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-collect-21" title="Link to this method">
                  <span class="method-callseq">
                    collect! &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="collect-21-source">
            <pre>static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY_AREF(ary, i)));
    }
    return ary;
}</pre>
          </div>
          <p>With a block given, calls the block with each element of <code>self</code> and replaces the element with the block’s return value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> } <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: <a href="Array.html#method-i-collect"><code>collect</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-map-21">map!</a>
        </div>

      </div>

      <div id="method-i-combination" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-combination" title="Link to this method">
                  <span class="method-callseq">
                    combination(count) {|element| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-combination" title="Link to this method">
                  <span class="method-callseq">
                    combination(count) &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="combination-source">
            <pre>static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long i, n, len;

    n = NUM2LONG(num);
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_combination_size);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        volatile VALUE t0;
        long *stack = ALLOCV_N(long, t0, n+1);

        RBASIC_CLEAR_CLASS(ary0);
        combinate0(len, n, stack, ary0);
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
          <p>When a block and a positive <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a> argument <code>count</code> (<code>0 &lt; count &lt;= self.size</code>) are given, calls the block with each combination of <code>self</code> of size <code>count</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w[a b c]</span>                                   <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</pre>

<p>Output:</p>

<pre class="ruby">[<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>]
[<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>]
[<span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>]
</pre>

<p>The order of the yielded combinations is not guaranteed.</p>

<p>When <code>count</code> is zero, calls the block once with a new empty array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
[].<span class="ruby-identifier">combination</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">combination</span> }
</pre>

<p>Output:</p>

<pre class="ruby">[]
[]
</pre>

<p>When <code>count</code> is negative or larger than <code>self.size</code> and <code>self</code> is non-empty, does not call the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">4</span>)  {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: <a href="Array.html#method-i-permutation"><code>Array#permutation</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p>
        </div>


      </div>

      <div id="method-i-compact" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-compact" title="Link to this method">
                  <span class="method-callseq">
                    compact &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="compact-source">
            <pre>static VALUE
rb_ary_compact(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}</pre>
          </div>
          <p>Returns a new array containing only the non-<code>nil</code> elements from <code>self</code>; element order is preserved:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-keyword">nil</span>, [], <span class="ruby-keyword">nil</span>, {}]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">compact</span> <span class="ruby-comment"># =&gt; [0, false, &quot;&quot;, [], {}]</span>
</pre>

<p>Related: <a href="Array.html#method-i-compact-21"><code>Array#compact!</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-compact-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-compact-21" title="Link to this method">
                  <span class="method-callseq">
                    compact! &rarr; self or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="compact-21-source">
            <pre>static VALUE
rb_ary_compact_bang(VALUE ary)
{
    VALUE *p, *t, *end;
    long n;

    rb_ary_modify(ary);
    p = t = (VALUE *)RARRAY_CONST_PTR(ary); /* WB: no new reference */
    end = p + RARRAY_LEN(ary);

    while (t &lt; end) {
        if (NIL_P(*t)) t++;
        else *p++ = *t++;
    }
    n = p - RARRAY_CONST_PTR(ary);
    if (RARRAY_LEN(ary) == n) {
        return Qnil;
    }
    ary_resize_smaller(ary, n);

    return ary;
}</pre>
          </div>
          <p>Removes all <code>nil</code> elements from <code>self</code>; Returns <code>self</code> if any elements are removed, <code>nil</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-keyword">nil</span>, [], <span class="ruby-keyword">nil</span>, {}]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">compact!</span> <span class="ruby-comment"># =&gt; [0, false, &quot;&quot;, [], {}]</span>
<span class="ruby-identifier">a</span>          <span class="ruby-comment"># =&gt; [0, false, &quot;&quot;, [], {}]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">compact!</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Related: <a href="Array.html#method-i-compact"><code>Array#compact</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-concat" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-concat" title="Link to this method">
                  <span class="method-callseq">
                    concat(*other_arrays) &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="concat-source">
            <pre>static VALUE
rb_ary_concat_multi(int argc, VALUE *argv, VALUE ary)
{
    rb_ary_modify_check(ary);

    if (argc == 1) {
        rb_ary_concat(ary, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE args = rb_ary_hidden_new(argc);
        for (i = 0; i &lt; argc; i++) {
            rb_ary_concat(args, argv[i]);
        }
        ary_append(ary, args);
    }

    ary_verify(ary);
    return ary;
}</pre>
          </div>
          <p>Adds to <code>self</code> all elements from each array in <code>other_arrays</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">concat</span>([<span class="ruby-string">&#39;two&#39;</span>, <span class="ruby-string">&#39;three&#39;</span>], [<span class="ruby-value">:four</span>, <span class="ruby-value">:five</span>], <span class="ruby-identifier">a</span>)
<span class="ruby-comment"># =&gt; [0, 1, &quot;two&quot;, &quot;three&quot;, :four, :five, 0, 1]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-count" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-count" title="Link to this method">
                  <span class="method-callseq">
                    count &rarr; integer
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-count" title="Link to this method">
                  <span class="method-callseq">
                    count(object) &rarr; integer
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-count" title="Link to this method">
                  <span class="method-callseq">
                    count {|element| ... } &rarr; integer
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="count-source">
            <pre>static VALUE
rb_ary_count(int argc, VALUE *argv, VALUE ary)
{
    long i, n = 0;

    if (rb_check_arity(argc, 0, 1) == 0) {
        VALUE v;

        if (!rb_block_given_p())
            return LONG2NUM(RARRAY_LEN(ary));

        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            v = RARRAY_AREF(ary, i);
            if (RTEST(rb_yield(v))) n++;
        }
    }
    else {
        VALUE obj = argv[0];

        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            if (rb_equal(RARRAY_AREF(ary, i), obj)) n++;
        }
    }

    return LONG2NUM(n);
}</pre>
          </div>
          <p>Returns a count of specified elements.</p>

<p>With no argument and no block, returns the count of all elements:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">:one</span>, <span class="ruby-string">&#39;two&#39;</span>, <span class="ruby-value">3</span>, <span class="ruby-value">3.0</span>].<span class="ruby-identifier">count</span> <span class="ruby-comment"># =&gt; 5</span>
</pre>

<p>With argument <code>object</code> given, returns the count of elements <code>==</code> to <code>object</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">:one</span>, <span class="ruby-string">&#39;two&#39;</span>, <span class="ruby-value">3</span>, <span class="ruby-value">3.0</span>].<span class="ruby-identifier">count</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>With no argument and a block given, calls the block with each element; returns the count of elements for which the block returns a truthy value:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">count</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> } <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>With argument <code>object</code> and a block given, issues a warning, ignores the block, and returns the count of elements <code>==</code> to <code>object</code>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-cycle" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-cycle" title="Link to this method">
                  <span class="method-callseq">
                    cycle(count = nil) {|element| ... } &rarr; nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-cycle" title="Link to this method">
                  <span class="method-callseq">
                    cycle(count = nil) &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="cycle-source">
            <pre>static VALUE
rb_ary_cycle(int argc, VALUE *argv, VALUE ary)
{
    long n, i;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_cycle_size);
    if (argc == 0 || NIL_P(argv[0])) {
        n = -1;
    }
    else {
        n = NUM2LONG(argv[0]);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY_LEN(ary) &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            rb_yield(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre>
          </div>
          <p>With a block given, may call the block, depending on the value of argument <code>count</code>; <code>count</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>, or <code>nil</code>.</p>

<p>When <code>count</code> is positive, calls the block with each element, then does so repeatedly, until it has done so <code>count</code> times; returns <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">output</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">output</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">element</span>) } <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">output</span> <span class="ruby-comment"># =&gt; [0, 1, 0, 1]</span>
</pre>

<p>When <code>count</code> is zero or negative, does not call the block:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }  <span class="ruby-comment"># =&gt; nil</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>When <code>count</code> is <code>nil</code>, cycles forever:</p>

<pre class="ruby"><span class="ruby-comment"># Prints 0 and 1 forever.</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">element</span> }
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">cycle</span>(<span class="ruby-keyword">nil</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">element</span> }
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p>
        </div>


      </div>

      <div id="method-i-delete" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-delete" title="Link to this method">
                  <span class="method-callseq">
                    delete(object) &rarr; last_removed_object
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-delete" title="Link to this method">
                  <span class="method-callseq">
                    delete(object) {|element| ... } &rarr; last_removed_object or block_return
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="delete-source">
            <pre>VALUE
rb_ary_delete(VALUE ary, VALUE item)
{
    VALUE v = item;
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE e = RARRAY_AREF(ary, i1);

        if (rb_equal(e, item)) {
            v = e;
            continue;
        }
        if (i1 != i2) {
            rb_ary_store(ary, i2, e);
        }
        i2++;
    }
    if (RARRAY_LEN(ary) == i2) {
        if (rb_block_given_p()) {
            return rb_yield(item);
        }
        return Qnil;
    }

    ary_resize_smaller(ary, i2);

    ary_verify(ary);
    return v;
}</pre>
          </div>
          <p>Removes zero or more elements from <code>self</code>.</p>

<p>With no block given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == object</code>; returns the last removed element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2.0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; 2.0</span>
<span class="ruby-identifier">a</span>           <span class="ruby-comment"># =&gt; [0, 1]</span>
</pre>

<p>Returns <code>nil</code> if no elements removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With a block given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == object</code>.</p>

<p>If any such elements are found, ignores the block and returns the last removed element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2.0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; 2.0</span>
<span class="ruby-identifier">a</span>                                             <span class="ruby-comment"># =&gt; [0, 1]</span>
</pre>

<p>If no such element is found, returns the block’s return value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Element #{element} not found.&quot;</span> }
<span class="ruby-comment"># =&gt; &quot;Element 2 not found.&quot;</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-delete_at" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-delete_at" title="Link to this method">
                  <span class="method-callseq">
                    delete_at(index) &rarr; removed_object or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="delete_at-source">
            <pre>static VALUE
rb_ary_delete_at_m(VALUE ary, VALUE pos)
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}</pre>
          </div>
          <p>Removes the element of <code>self</code> at the given <code>index</code>, which must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>.</p>

<p>When <code>index</code> is non-negative, deletes the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>When <code>index</code> is negative, counts backward from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>When <code>index</code> is out of range, returns <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">-4</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-delete_if" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-delete_if" title="Link to this method">
                  <span class="method-callseq">
                    delete_if {|element| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-delete_if" title="Link to this method">
                  <span class="method-callseq">
                    delete_if &rarr; new_numerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="delete_if-source">
            <pre>static VALUE
rb_ary_delete_if(VALUE ary)
{
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    ary_reject_bang(ary);
    return ary;
}</pre>
          </div>
          <p>With a block given, calls the block with each element of <code>self</code>; removes the element if the block returns a truthy value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bat&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-difference" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-difference" title="Link to this method">
                  <span class="method-callseq">
                    difference(*other_arrays = []) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="difference-source">
            <pre>static VALUE
rb_ary_difference_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE ary_diff;
    long i, length;
    volatile VALUE t0;
    bool *is_hash = ALLOCV_N(bool, t0, argc);
    ary_diff = rb_ary_new();
    length = RARRAY_LEN(ary);

    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        is_hash[i] = (length &gt; SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(argv[i]) &gt; SMALL_ARRAY_LEN);
        if (is_hash[i]) argv[i] = ary_make_hash(argv[i]);
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        int j;
        VALUE elt = rb_ary_elt(ary, i);
        for (j = 0; j &lt; argc; j++) {
            if (is_hash[j]) {
                if (rb_hash_stlike_lookup(argv[j], RARRAY_AREF(ary, i), NULL))
                    break;
            }
            else {
                if (rb_ary_includes_by_eql(argv[j], elt)) break;
            }
        }
        if (j == argc) rb_ary_push(ary_diff, elt);
    }

    ALLOCV_END(t0);

    return ary_diff;
}</pre>
          </div>
          <p>Returns a new array containing only those elements from <code>self</code> that are not found in any of the given <code>other_arrays</code>; items are compared using <code>eql?</code>;  order from <code>self</code> is preserved:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">difference</span>([<span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; [0, 2, 3]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">difference</span>([<span class="ruby-value">3</span>, <span class="ruby-value">0</span>], [<span class="ruby-value">1</span>, <span class="ruby-value">3</span>])     <span class="ruby-comment"># =&gt; [2]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">difference</span>([<span class="ruby-value">4</span>])                   <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">difference</span>                        <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Returns a copy of <code>self</code> if no arguments are given.</p>

<p>Related: <a href="Array.html#method-i-2D"><code>Array#-</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-dig" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-dig" title="Link to this method">
                  <span class="method-callseq">
                    dig(index, *identifiers) &rarr; object
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="dig-source">
            <pre>static VALUE
rb_ary_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_ary_at(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre>
          </div>
          <p>Finds and returns the object in nested object specified by <code>index</code> and <code>identifiers</code>; the nested objects may be instances of various classes. See <a href="dig_methods_rdoc.html">Dig Methods</a>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, [<span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>, [<span class="ruby-value">:bat</span>, <span class="ruby-value">:bam</span>]]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [:bar, :baz, [:bat, :bam]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:bat, :bam]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; :bat</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-drop" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-drop" title="Link to this method">
                  <span class="method-callseq">
                    drop(count) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="drop-source">
            <pre>static VALUE
rb_ary_drop(VALUE ary, VALUE n)
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_subseq(ary, pos, RARRAY_LEN(ary));
    if (NIL_P(result)) result = rb_ary_new();
    return result;
}</pre>
          </div>
          <p>Returns a new array containing all but the first <code>count</code> element of <code>self</code>, where <code>count</code> is a non-negative integer; does not modify <code>self</code>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">9</span>) <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-drop_while" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-drop_while" title="Link to this method">
                  <span class="method-callseq">
                    drop_while {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-drop_while" title="Link to this method">
                  <span class="method-callseq">
                    drop_while &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="drop_while-source">
            <pre>static VALUE
rb_ary_drop_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}</pre>
          </div>
          <p>With a block given, calls the block with each successive element of <code>self</code>; stops if the block returns <code>false</code> or <code>nil</code>; returns a new array <em>omitting</em> those elements for which the block returned a truthy value; does not modify <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; [3, 4, 5]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-each" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-each" title="Link to this method">
                  <span class="method-callseq">
                    each {|element| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-each" title="Link to this method">
                  <span class="method-callseq">
                    each &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="each-source">
            <pre>VALUE
rb_ary_each(VALUE ary)
{
    long i;
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(RARRAY_AREF(ary, i));
    }
    return ary;
}</pre>
          </div>
          <p>With a block given, iterates over the elements of <code>self</code>, passing each element to the block; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{element.class} #{element}&quot;</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-constant">Symbol</span> <span class="ruby-identifier">foo</span>
<span class="ruby-constant">String</span> <span class="ruby-identifier">bar</span>
<span class="ruby-constant">Integer</span> <span class="ruby-value">2</span>
</pre>

<p>Allows the array to be modified during iteration:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">element</span>; <span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">foo</span>
<span class="ruby-identifier">bar</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p>
        </div>


      </div>

      <div id="method-i-each_index" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-each_index" title="Link to this method">
                  <span class="method-callseq">
                    each_index {|index| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-each_index" title="Link to this method">
                  <span class="method-callseq">
                    each_index &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="each_index-source">
            <pre>static VALUE
rb_ary_each_index(VALUE ary)
{
    long i;
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(LONG2NUM(i));
    }
    return ary;
}</pre>
          </div>
          <p>With a block given, iterates over the elements of <code>self</code>, passing each <em>array index</em> to the block; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{index} #{a[index]}&quot;</span> }
</pre>

<p>Output:</p>

<pre>0 foo
1 bar
2 2</pre>

<p>Allows the array to be modified during iteration:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">index</span>; <span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-value">0</span>
<span class="ruby-value">1</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p>
        </div>


      </div>

      <div id="method-i-empty-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-empty-3F" title="Link to this method">
                  <span class="method-callseq">
                    empty?  &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="empty-3F-source">
            <pre>static VALUE
rb_ary_empty_p(VALUE ary)
{
    return RBOOL(RARRAY_LEN(ary) == 0);
}</pre>
          </div>
          <p>Returns <code>true</code> if the count of elements in <code>self</code> is zero, <code>false</code> otherwise.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-eql-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-eql-3F" title="Link to this method">
                  <span class="method-callseq">
                    eql?(other_array) &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="eql-3F-source">
            <pre>static VALUE
rb_ary_eql(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) return Qfalse;
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_eql, ary1, ary2, ary2);
}</pre>
          </div>
          <p>Returns <code>true</code> if <code>self</code> and <code>other_array</code> are the same size, and if, for each index <code>i</code> in <code>self</code>, <code>self[i].eql?(other_array[i])</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a0</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Otherwise, returns <code>false</code>.</p>

<p>This method is different from method <a href="Array.html#method-i-3D-3D"><code>Array#==</code></a>, which compares using method <a href="BasicObject.html#method-i-3D-3D"><code>Object#==</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-fetch" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-fetch" title="Link to this method">
                  <span class="method-callseq">
                    fetch(index) &rarr; element
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-fetch" title="Link to this method">
                  <span class="method-callseq">
                    fetch(index, default_value) &rarr; element or default_value
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-fetch" title="Link to this method">
                  <span class="method-callseq">
                    fetch(index) {|index| ... } &rarr; element or block_return_value
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="fetch-source">
            <pre>static VALUE
rb_ary_fetch(int argc, VALUE *argv, VALUE ary)
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
        idx +=  RARRAY_LEN(ary);
    }
    if (idx &lt; 0 || RARRAY_LEN(ary) &lt;= idx) {
        if (block_given) return rb_yield(pos);
        if (argc == 1) {
            rb_raise(rb_eIndexError, &quot;index %ld outside of array bounds: %ld...%ld&quot;,
                        idx - (idx &lt; 0 ? RARRAY_LEN(ary) : 0), -RARRAY_LEN(ary), RARRAY_LEN(ary));
        }
        return ifnone;
    }
    return RARRAY_AREF(ary, idx);
}</pre>
          </div>
          <p>Returns the element of <code>self</code> at offset <code>index</code> if <code>index</code> is in range; <code>index</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>.</p>

<p>With the single argument <code>index</code> and no block, returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1.1</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>If <code>index</code> is negative, counts from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>With arguments <code>index</code> and <code>default_value</code> (which may be any object) and no block, returns <code>default_value</code> if <code>index</code> is out-of-range:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>, <span class="ruby-keyword">nil</span>)  <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">3</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; :foo</span>
</pre>

<p>With argument <code>index</code> and a block, returns the element at offset <code>index</code> if index is in range (and the block is not called); otherwise calls the block with index and returns its return value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">50</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Value for #{index}&quot;</span> } <span class="ruby-comment"># =&gt; &quot;Value for 50&quot;</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-fetch_values" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-fetch_values" title="Link to this method">
                  <span class="method-callseq">
                    fetch_values(*indexes) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-fetch_values" title="Link to this method">
                  <span class="method-callseq">
                    fetch_values(*indexes) { |index| ... } &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="fetch_values-source">
            <pre><span class="ruby-comment"># File array.rb, line 210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch_values</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">indexes</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">indexes</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fetch</span>(<span class="ruby-identifier">i</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) }
  <span class="ruby-identifier">indexes</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>With no block given, returns a new array containing the elements of <code>self</code> at the offsets specified by <code>indexes</code>. Each of the <code>indexes</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">2</span>, <span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; [:baz, :foo]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">2.1</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [:baz, :foo]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch_values</span>         <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>For a negative index, counts backwards from the end of the array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># [:bar, :baz]</span>
</pre>

<p>When no block is given, raises an exception if any index is out of range.</p>

<p>With a block given, for each index:</p>
<ul><li>
<p>If the index is in range, uses an element of <code>self</code> (as above).</p>
</li><li>
<p>Otherwise, calls the block with the index and uses the block’s return value.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">42</span>, <span class="ruby-value">777</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">index</span>.<span class="ruby-identifier">to_s</span> }
<span class="ruby-comment"># =&gt; [:bar, :foo, &quot;42&quot;, &quot;777&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-fill" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-fill" title="Link to this method">
                  <span class="method-callseq">
                    fill(object, start = nil, count = nil) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-fill" title="Link to this method">
                  <span class="method-callseq">
                    fill(object, range) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-fill" title="Link to this method">
                  <span class="method-callseq">
                    fill(start = nil, count = nil) {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-fill" title="Link to this method">
                  <span class="method-callseq">
                    fill(range) {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="fill-source">
            <pre>static VALUE
rb_ary_fill(int argc, VALUE *argv, VALUE ary)
{
    VALUE item = Qundef, arg1, arg2;
    long beg = 0, end = 0, len = 0;

    if (rb_block_given_p()) {
        rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
        argc += 1;              /* hackish */
    }
    else {
        rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
        beg = 0;
        len = RARRAY_LEN(ary);
        break;
      case 2:
        if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
            break;
        }
        /* fall through */
      case 3:
        beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
        if (beg &lt; 0) {
            beg = RARRAY_LEN(ary) + beg;
            if (beg &lt; 0) beg = 0;
        }
        len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
        break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    end = beg + len;
    if (RARRAY_LEN(ary) &lt; end) {
        if (end &gt;= ARY_CAPA(ary)) {
            ary_resize_capa(ary, end);
        }
        ary_mem_clear(ary, RARRAY_LEN(ary), end - RARRAY_LEN(ary));
        ARY_SET_LEN(ary, end);
    }

    if (UNDEF_P(item)) {
        VALUE v;
        long i;

        for (i=beg; i&lt;end; i++) {
            v = rb_yield(LONG2NUM(i));
            if (i&gt;=RARRAY_LEN(ary)) break;
            ARY_SET(ary, i, v);
        }
    }
    else {
        ary_memfill(ary, beg, len, item);
    }
    return ary;
}</pre>
          </div>
          <p>Replaces selected elements in <code>self</code>; may add elements to <code>self</code>; always returns <code>self</code> (never a new array).</p>

<p>In brief:</p>

<pre class="ruby"><span class="ruby-comment"># Non-negative start.</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>

<span class="ruby-comment"># Extends with specified values if necessary.</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;-&quot;, &quot;-&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">3</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;3&quot;, &quot;4&quot;]</span>

<span class="ruby-comment"># Fills with nils if necessary.</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">6</span>, <span class="ruby-value">2</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, nil, &quot;-&quot;, &quot;-&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">6</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, nil, &quot;6&quot;, &quot;7&quot;]</span>

<span class="ruby-comment"># For negative start, counts backwards from the end.</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-3</span>, <span class="ruby-value">3</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-3</span>, <span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span>

<span class="ruby-comment"># Range.</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
</pre>

<p>When arguments <code>start</code> and <code>count</code> are given, they select the elements of <code>self</code> to be replaced; each must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a> (or <code>nil</code>):</p>
<ul><li>
<p><code>start</code> specifies the zero-based offset of the first element to be replaced; <code>nil</code> means zero.</p>
</li><li>
<p><code>count</code> is the number of consecutive elements to be replaced; <code>nil</code> means “all the rest.”</p>
</li></ul>

<p>With argument <code>object</code> given, that one object is used for all replacements:</p>

<pre class="ruby"><span class="ruby-identifier">o</span> = <span class="ruby-constant">Object</span>.<span class="ruby-identifier">new</span>           <span class="ruby-comment"># =&gt; #&lt;Object:0x0000014e7bff7600&gt;</span>
<span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>] <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-identifier">o</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>)
<span class="ruby-comment"># =&gt; [&quot;a&quot;, #&lt;Object:0x0000014e7bff7600&gt;, #&lt;Object:0x0000014e7bff7600&gt;, &quot;d&quot;]</span>
</pre>

<p>With a block given, the block is called once for each element to be replaced; the value passed to the block is the <em>index</em> of the element to be replaced (not the element itself); the block’s return value replaces the element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]               <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
</pre>

<p>For arguments <code>start</code> and <code>count</code>:</p>
<ul><li>
<p>If <code>start</code> is non-negative, replaces <code>count</code> elements beginning at offset <code>start</code>:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;-&quot;, &quot;-&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;-&quot;, &quot;-&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">0</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;0&quot;, &quot;1&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">2</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;2&quot;, &quot;3&quot;]</span>
</pre>

<p>Extends <code>self</code> if necessary:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;-&quot;, &quot;-&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;-&quot;, &quot;-&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">3</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;3&quot;, &quot;4&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">4</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;4&quot;, &quot;5&quot;]</span>
</pre>

<p>Fills with <code>nil</code> if necessary:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">5</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, &quot;-&quot;, &quot;-&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">6</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, nil, &quot;-&quot;, &quot;-&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">5</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, &quot;5&quot;, &quot;6&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">6</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, nil, &quot;6&quot;, &quot;7&quot;]</span>
</pre>

<p>Does nothing if <code>count</code> is non-positive:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>)    <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">-100</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">6</span>, <span class="ruby-value">-100</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">2</span>, <span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }    <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">2</span>, <span class="ruby-value">-100</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">6</span>, <span class="ruby-value">-100</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
</li><li>
<p>If <code>start</code> is negative, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-4</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [&quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-3</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-4</span>, <span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-3</span>, <span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span>
</pre>

<p>Extends <code>self</code> if necessary:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-1</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-1</span>, <span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span>
</pre>

<p>Starts at the beginning of <code>self</code> if <code>start</code> is negative and out-of-range:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-5</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;-&quot;, &quot;-&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-6</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;-&quot;, &quot;-&quot;, &quot;c&quot;, &quot;d&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-5</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;0&quot;, &quot;1&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-6</span>, <span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;0&quot;, &quot;1&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>Does nothing if <code>count</code> is non-positive:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">0</span>)  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
</li></ul>

<p>When argument <code>range</code> is given, it must be a <a href="Range.html"><code>Range</code></a> object whose members are numeric; its <code>begin</code> and <code>end</code> values determine the elements of <code>self</code> to be replaced:</p>
<ul><li>
<p>If both <code>begin</code> and <code>end</code> are positive, they specify the first and last elements to be replaced:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>end</code> is smaller than <code>begin</code>, replaces no elements:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
</li><li>
<p>If either is negative (or both are negative), counts backwards from the end of <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>)  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> }  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> }  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
</pre>
</li><li>
<p>If the <code>end</code> value is excluded (see <a href="Range.html#method-i-exclude_end-3F"><code>Range#exclude_end?</code></a>), omits the last replacement:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">2</span>)  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;c&quot;, &quot;d&quot;]</span>

[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> }  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;c&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">-2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
</li><li>
<p>If the range is endless (see <a href="Range.html#class-Range-label-Endless+Ranges">Endless Ranges</a>), replaces elements to the end of <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-value">1</span><span class="ruby-operator">..</span>)          <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span>
</pre>
</li><li>
<p>If the range is beginless (see <a href="Range.html#class-Range-label-Beginless+Ranges">Beginless Ranges</a>), replaces elements from the beginning of <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-string">&#39;-&#39;</span>, <span class="ruby-operator">..</span><span class="ruby-value">2</span>)          <span class="ruby-comment"># =&gt; [&quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;d&quot;]</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>].<span class="ruby-identifier">fill</span>(<span class="ruby-operator">..</span><span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span> } <span class="ruby-comment"># =&gt; [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;d&quot;]</span>
</pre>
</li></ul>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-filter" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-filter" title="Link to this method">
                  <span class="method-callseq">
                    filter {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-filter" title="Link to this method">
                  <span class="method-callseq">
                    filter &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>With a block given, calls the block with each element of <code>self</code>; returns a new array containing those elements of <code>self</code> for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-select">select</a>
        </div>
      </div>

      <div id="method-i-filter-21" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-filter-21" title="Link to this method">
                  <span class="method-callseq">
                    filter! {|element| ... } &rarr; self or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-filter-21" title="Link to this method">
                  <span class="method-callseq">
                    filter! &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>With a block given, calls the block with each element of <code>self</code>; removes from <code>self</code> those elements for which the block returns <code>false</code> or <code>nil</code>.</p>

<p>Returns <code>self</code> if any elements were removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>Returns <code>nil</code> if no elements were removed.</p>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-select-21">select!</a>
        </div>
      </div>

      <div id="method-i-find_index" class="method-detail anchor-link ">
        <div class="method-header">
            <div class="method-heading">
              <a href="#method-i-find_index" title="Link to this method">
                <span class="method-name">find_index</span>
              </a>
            </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>


        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-index">index</a>
        </div>

      </div>

      <div id="method-i-first" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-first" title="Link to this method">
                  <span class="method-callseq">
                    first &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-first" title="Link to this method">
                  <span class="method-callseq">
                    first(count) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="first-source">
            <pre><span class="ruby-comment"># File array.rb, line 129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first</span> <span class="ruby-identifier">n</span> = <span class="ruby-identifier">unspecified</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">mandatory_only?</span>
    <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">attr!</span> <span class="ruby-value">:leaf</span>
    <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">cexpr!</span> <span class="ruby-string">%q{ ary_first(self) }</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">unspecified</span>
      <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">cexpr!</span> <span class="ruby-string">%q{ ary_first(self) }</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">cexpr!</span> <span class="ruby-string">%q{  ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_FIRST) }</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Returns elements from <code>self</code>, or <code>nil</code>; does not modify <code>self</code>.</p>

<p>With no argument given, returns the first element (if available):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span> <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>self</code> is empty, returns <code>nil</code>.</p>

<pre class="ruby">[].<span class="ruby-identifier">first</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With a non-negative integer argument <code>count</code> given, returns the first <code>count</code> elements (as available) in a new array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">0</span>)  <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-flatten" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-flatten" title="Link to this method">
                  <span class="method-callseq">
                    flatten(depth = nil) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="flatten-source">
            <pre>static VALUE
rb_ary_flatten(int argc, VALUE *argv, VALUE ary)
{
    int level = -1;
    VALUE result;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0])) {
        level = NUM2INT(argv[0]);
        if (level == 0) return ary_make_shared_copy(ary);
    }

    result = flatten(ary, level);
    if (result == ary) {
        result = ary_make_shared_copy(ary);
    }

    return result;
}</pre>
          </div>
          <p>Returns a new array that is a recursive flattening of <code>self</code> to <code>depth</code> levels of recursion; <code>depth</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a> or <code>nil</code>. At each level of recursion:</p>
<ul><li>
<p>Each element that is an array is “flattened” (that is, replaced by its individual array elements).</p>
</li><li>
<p>Each element that is not an array is unchanged (even if the element is an object that has instance method <code>flatten</code>).</p>
</li></ul>

<p>With non-negative integer argument <code>depth</code>, flattens recursively through <code>depth</code> levels:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span>, {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}, <span class="ruby-constant">Set</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">6</span>, <span class="ruby-value">7</span>]) ]
<span class="ruby-identifier">a</span>              <span class="ruby-comment"># =&gt; [0, [1, [2, 3], 4], 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; [0, [1, [2, 3], 4], 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">1</span>  ) <span class="ruby-comment"># =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">1.1</span>) <span class="ruby-comment"># =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">3</span>)   <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
</pre>

<p>With <code>nil</code> or negative <code>depth</code>, flattens all levels.</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>     <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
</pre>

<p>Related: <a href="Array.html#method-i-flatten-21"><code>Array#flatten!</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


      </div>

      <div id="method-i-flatten-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-flatten-21" title="Link to this method">
                  <span class="method-callseq">
                    flatten!(depth = nil) &rarr; self or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="flatten-21-source">
            <pre>static VALUE
rb_ary_flatten_bang(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    lv = (rb_check_arity(argc, 0, 1) ? argv[0] : Qnil);
    rb_ary_modify_check(ary);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return Qnil;

    result = flatten(ary, level);
    if (result == ary) {
        return Qnil;
    }
    if (!(mod = ARY_EMBED_P(result))) rb_ary_freeze(result);
    rb_ary_replace(ary, result);
    if (mod) ARY_SET_EMBED_LEN(result, 0);

    return ary;
}</pre>
          </div>
          <p>Returns <code>self</code> as a recursively flattening of <code>self</code> to <code>depth</code> levels of recursion; <code>depth</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>, or <code>nil</code>. At each level of recursion:</p>
<ul><li>
<p>Each element that is an array is “flattened” (that is, replaced by its individual array elements).</p>
</li><li>
<p>Each element that is not an array is unchanged (even if the element is an object that has instance method <code>flatten</code>).</p>
</li></ul>

<p>Returns <code>nil</code> if no elements were flattened.</p>

<p>With non-negative integer argument <code>depth</code>, flattens recursively through <code>depth</code> levels:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">0</span>, [ <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-value">4</span> ], <span class="ruby-value">5</span>, {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}, <span class="ruby-constant">Set</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">6</span>, <span class="ruby-value">7</span>]) ]
<span class="ruby-identifier">a</span>                   <span class="ruby-comment"># =&gt; [0, [1, [2, 3], 4], 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment"># =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">1.1</span>) <span class="ruby-comment"># =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">3</span>)   <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
</pre>

<p>With <code>nil</code> or negative argument <code>depth</code>, flattens all levels:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">flatten!</span>     <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]</span>
</pre>

<p>Related: <a href="Array.html#method-i-flatten"><code>Array#flatten</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-freeze" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-freeze" title="Link to this method">
                  <span class="method-callseq">
                    freeze &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="freeze-source">
            <pre>VALUE
rb_ary_freeze(VALUE ary)
{
    RUBY_ASSERT(RB_TYPE_P(ary, T_ARRAY));

    if (OBJ_FROZEN(ary)) return ary;

    if (!ARY_EMBED_P(ary) &amp;&amp; !ARY_SHARED_P(ary) &amp;&amp; !ARY_SHARED_ROOT_P(ary)) {
        ary_shrink_capa(ary);
    }

    return rb_obj_freeze(ary);
}</pre>
          </div>
          <p>Freezes <code>self</code> (if not already frozen); returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = []
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">frozen?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">freeze</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">frozen?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>No further changes may be made to <code>self</code>; raises <a href="FrozenError.html"><code>FrozenError</code></a> if a change is attempted.</p>

<p>Related: <a href="Kernel.html#method-i-frozen-3F"><code>Kernel#frozen?</code></a>.</p>
        </div>


      </div>

      <div id="method-i-hash" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-hash" title="Link to this method">
                  <span class="method-callseq">
                    hash &rarr; integer
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="hash-source">
            <pre>static VALUE
rb_ary_hash(VALUE ary)
{
    return rb_ary_hash_values(RARRAY_LEN(ary), RARRAY_CONST_PTR(ary));
}</pre>
          </div>
          <p>Returns the integer hash value for <code>self</code>.</p>

<p>Two arrays with the same content will have the same hash value (and will compare using eql?):</p>

<pre class="ruby">[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>].<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>].<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>].<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>].<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>].<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> [<span class="ruby-string">&#39;a&#39;</span>].<span class="ruby-identifier">hash</span>      <span class="ruby-comment"># =&gt; false</span>
</pre>
        </div>


      </div>

      <div id="method-i-include-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-include-3F" title="Link to this method">
                  <span class="method-callseq">
                    include?(object) &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="include-3F-source">
            <pre>VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
    long i;
    VALUE e;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (rb_equal(e, item)) {
            return Qtrue;
        }
    }
    return Qfalse;
}</pre>
          </div>
          <p>Returns whether for some element <code>element</code> in <code>self</code>, <code>object == element</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-value">2.0</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-value">2.1</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-index" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-index" title="Link to this method">
                  <span class="method-callseq">
                    index(object) &rarr; integer or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-index" title="Link to this method">
                  <span class="method-callseq">
                    index {|element| ... } &rarr; integer or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-index" title="Link to this method">
                  <span class="method-callseq">
                    index &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>Returns the zero-based integer index of a specified element, or <code>nil</code>.</p>

<p>With only argument <code>object</code> given, returns the index of the first element <code>element</code> for which <code>object == element</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Returns <code>nil</code> if no such element found.</p>

<p>With only a block given, calls the block with each successive element; returns the index of the first element for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Returns <code>nil</code> if the block never returns a truthy value.</p>

<p>With neither an argument nor a block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-find_index">find_index</a>
        </div>
      </div>

      <div id="method-i-initialize_copy" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-initialize_copy" title="Link to this method">
                  <span class="method-callseq">
                    initialize_copy(other_array) &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="initialize_copy-source">
            <pre>VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    rb_ary_reset(copy);

    /* orig has enough space to embed the contents of orig. */
    if (RARRAY_LEN(orig) &lt;= ary_embed_capa(copy)) {
        RUBY_ASSERT(ARY_EMBED_P(copy));
        ary_memcpy(copy, 0, RARRAY_LEN(orig), RARRAY_CONST_PTR(orig));
        ARY_SET_EMBED_LEN(copy, RARRAY_LEN(orig));
    }
    /* orig is embedded but copy does not have enough space to embed the
     * contents of orig. */
    else if (ARY_EMBED_P(orig)) {
        long len = ARY_EMBED_LEN(orig);
        VALUE *ptr = ary_heap_alloc_buffer(len);

        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, ptr);
        ARY_SET_LEN(copy, len);
        ARY_SET_CAPA(copy, len);

        // No allocation and exception expected that could leave `copy` in a
        // bad state from the edits above.
        ary_memcpy(copy, 0, len, RARRAY_CONST_PTR(orig));
    }
    /* Otherwise, orig is on heap and copy does not have enough space to embed
     * the contents of orig. */
    else {
        VALUE shared_root = ary_make_shared(orig);
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, ARY_HEAP_PTR(orig));
        ARY_SET_LEN(copy, ARY_HEAP_LEN(orig));
        rb_ary_set_shared(copy, shared_root);
    }
    ary_verify(copy);
    return copy;
}</pre>
          </div>
          <p>Replaces the elements of <code>self</code> with the elements of <code>other_array</code>, which must be an <a href="implicit_conversion_rdoc.html#label-Array-Convertible+Objects">array-convertible object</a>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>]   <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([<span class="ruby-string">&#39;d&#39;</span>, <span class="ruby-string">&#39;e&#39;</span>]) <span class="ruby-comment"># =&gt; [&quot;d&quot;, &quot;e&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-replace">replace</a>
        </div>

      </div>

      <div id="method-i-insert" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-insert" title="Link to this method">
                  <span class="method-callseq">
                    insert(index, *objects) &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="insert-source">
            <pre>static VALUE
rb_ary_insert(int argc, VALUE *argv, VALUE ary)
{
    long pos;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    rb_ary_modify_check(ary);
    pos = NUM2LONG(argv[0]);
    if (argc == 1) return ary;
    if (pos == -1) {
        pos = RARRAY_LEN(ary);
    }
    else if (pos &lt; 0) {
        long minpos = -RARRAY_LEN(ary) - 1;
        if (pos &lt; minpos) {
            rb_raise(rb_eIndexError, &quot;index %ld too small for array; minimum: %ld&quot;,
                     pos, minpos);
        }
        pos++;
    }
    rb_ary_splice(ary, pos, 0, argv + 1, argc - 1);
    return ary;
}</pre>
          </div>
          <p>Inserts the given <code>objects</code> as elements of <code>self</code>; returns <code>self</code>.</p>

<p>When <code>index</code> is non-negative, inserts <code>objects</code> <em>before</em> the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>]     <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">1</span>, <span class="ruby-value">:x</span>, <span class="ruby-value">:y</span>, <span class="ruby-value">:z</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, :x, :y, :z, &quot;b&quot;, &quot;c&quot;]</span>
</pre>

<p>Extends the array if <code>index</code> is beyond the array (<code>index &gt;= self.size</code>):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>]     <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:x</span>, <span class="ruby-value">:y</span>, <span class="ruby-value">:z</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, nil, :x, :y, :z]</span>
</pre>

<p>When <code>index</code> is negative, inserts <code>objects</code> <em>after</em> the element at offset <code>index + self.size</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>]      <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">:x</span>, <span class="ruby-value">:y</span>, <span class="ruby-value">:z</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, :x, :y, :z, &quot;c&quot;]</span>
</pre>

<p>With no <code>objects</code> given, does nothing:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>] <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">1</span>)         <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">50</span>)        <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-50</span>)       <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</pre>

<p>Raises <a href="IndexError.html"><code>IndexError</code></a> if <code>objects</code> are given and <code>index</code> is negative and out of range.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-inspect" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-inspect" title="Link to this method">
                  <span class="method-callseq">
                    inspect &rarr; new_string
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE
rb_ary_inspect(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0) return rb_usascii_str_new2(&quot;[]&quot;);
    return rb_exec_recursive(inspect_ary, ary, 0);
}</pre>
          </div>
          <p>Returns the new string formed by calling method <a href="Array.html#method-i-inspect"><code>inspect</code></a> on each array element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">inspect</span> <span class="ruby-comment"># =&gt; &quot;[:foo, \&quot;bar\&quot;, 2]&quot;</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-to_s">to_s</a>
        </div>

      </div>

      <div id="method-i-intersect-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-intersect-3F" title="Link to this method">
                  <span class="method-callseq">
                    intersect?(other_array) &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="intersect-3F-source">
            <pre>static VALUE
rb_ary_intersect_p(VALUE ary1, VALUE ary2)
{
    VALUE hash, v, result, shorter, longer;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary1) == 0 || RARRAY_LEN(ary2) == 0) return Qfalse;

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            v = RARRAY_AREF(ary1, i);
            if (rb_ary_includes_by_eql(ary2, v)) return Qtrue;
        }
        return Qfalse;
    }

    shorter = ary1;
    longer = ary2;
    if (RARRAY_LEN(ary1) &gt; RARRAY_LEN(ary2)) {
        longer = ary1;
        shorter = ary2;
    }

    hash = ary_make_hash(shorter);
    result = Qfalse;

    for (i=0; i&lt;RARRAY_LEN(longer); i++) {
        v = RARRAY_AREF(longer, i);
        vv = (st_data_t)v;
        if (rb_hash_stlike_lookup(hash, vv, 0)) {
            result = Qtrue;
            break;
        }
    }

    return result;
}</pre>
          </div>
          <p>Returns whether <code>other_array</code> has at least one element that is <a href="Array.html#method-i-eql-3F"><code>eql?</code></a> to some element of <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">intersect?</span>([<span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">intersect?</span>([<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Each element must correctly implement method <a href="Array.html#method-i-hash"><code>hash</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-intersection" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-intersection" title="Link to this method">
                  <span class="method-callseq">
                    intersection(*other_arrays) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="intersection-source">
            <pre>static VALUE
rb_ary_intersection_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = rb_ary_dup(ary);
    int i;

    for (i = 0; i &lt; argc; i++) {
        result = rb_ary_and(result, argv[i]);
    }

    return result;
}</pre>
          </div>
          <p>Returns a new array containing each element in <code>self</code> that is <a href="Array.html#method-i-eql-3F"><code>eql?</code></a> to at least one element in each of the given <code>other_arrays</code>; duplicates are omitted:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">intersection</span>([<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt; [0, 1]</span>
</pre>

<p>Each element must correctly implement method <a href="Array.html#method-i-hash"><code>hash</code></a>.</p>

<p>Order from <code>self</code> is preserved:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">intersection</span>([<span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>Returns a copy of <code>self</code> if no arguments are given.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-join" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-join" title="Link to this method">
                  <span class="method-callseq">
                    join(separator = $,) &rarr; new_string
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="join-source">
            <pre>static VALUE
rb_ary_join_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE sep;

    if (rb_check_arity(argc, 0, 1) == 0 || NIL_P(sep = argv[0])) {
        sep = rb_output_fs;
        if (!NIL_P(sep)) {
            rb_category_warn(RB_WARN_CATEGORY_DEPRECATED, &quot;$, is set to non-nil value&quot;);
        }
    }

    return rb_ary_join(ary, sep);
}</pre>
          </div>
          <p>Returns the new string formed by joining the converted elements of <code>self</code>; for each element <code>element</code>:</p>
<ul><li>
<p>Converts recursively using <code>element.join(separator)</code> if <code>element</code> is a <code>kind_of?(Array)</code>.</p>
</li><li>
<p>Otherwise, converts using <code>element.to_s</code>.</p>
</li></ul>

<p>With no argument given, joins using the output field separator, <code>$,</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">$,</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span> <span class="ruby-comment"># =&gt; &quot;foobar2&quot;</span>
</pre>

<p>With string argument <code>separator</code> given, joins using that separator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;\n&quot;</span>) <span class="ruby-comment"># =&gt; &quot;foo\nbar\n2&quot;</span>
</pre>

<p>Joins recursively for nested arrays:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, [<span class="ruby-value">:bar</span>, [<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>]]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span> <span class="ruby-comment"># =&gt; &quot;foobarbazbat&quot;</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


      </div>

      <div id="method-i-keep_if" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-keep_if" title="Link to this method">
                  <span class="method-callseq">
                    keep_if {|element| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-keep_if" title="Link to this method">
                  <span class="method-callseq">
                    keep_if &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="keep_if-source">
            <pre>static VALUE
rb_ary_keep_if(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_select_bang(ary);
    return ary;
}</pre>
          </div>
          <p>With a block given, calls the block with each element of <code>self</code>; removes the element from <code>self</code> if the block does not return a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">keep_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-last" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-last" title="Link to this method">
                  <span class="method-callseq">
                    last  &rarr; last_object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-last" title="Link to this method">
                  <span class="method-callseq">
                    last(count) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="last-source">
            <pre><span class="ruby-comment"># File array.rb, line 166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last</span> <span class="ruby-identifier">n</span> = <span class="ruby-identifier">unspecified</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">mandatory_only?</span>
    <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">attr!</span> <span class="ruby-value">:leaf</span>
    <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">cexpr!</span> <span class="ruby-string">%q{ ary_last(self) }</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">unspecified</span>
      <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">cexpr!</span> <span class="ruby-string">%q{ ary_last(self) }</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">cexpr!</span> <span class="ruby-string">%q{ ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_LAST) }</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Returns elements from <code>self</code>, or <code>nil</code>; <code>self</code> is not modified.</p>

<p>With no argument given, returns the last element, or <code>nil</code> if <code>self</code> is empty:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
[].<span class="ruby-identifier">last</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With non-negative integer argument <code>count</code> given, returns a new array containing the trailing <code>count</code> elements of <code>self</code>, as available:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">0</span>)  <span class="ruby-comment"># =&gt; []</span>
[].<span class="ruby-identifier">last</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-length" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-length" title="Link to this method">
                  <span class="method-callseq">
                    length &rarr; integer
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="length-source">
            <pre>static VALUE
rb_ary_length(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    return LONG2NUM(len);
}</pre>
          </div>
          <p>Returns the count of elements in <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">length</span> <span class="ruby-comment"># =&gt; 3</span>
[].<span class="ruby-identifier">length</span>        <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-size">size</a>
        </div>

      </div>

      <div id="method-i-map" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-map" title="Link to this method">
                  <span class="method-callseq">
                    map {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-map" title="Link to this method">
                  <span class="method-callseq">
                    map &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>With a block given, calls the block with each element of <code>self</code>; returns a new array whose elements are the return values from the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: <a href="Array.html#method-i-collect-21"><code>collect!</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: collect
        </div>

        <div class="aliases">
          Alias for: <a href="Array.html#method-i-collect">collect</a>
        </div>
      </div>

      <div id="method-i-map-21" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-map-21" title="Link to this method">
                  <span class="method-callseq">
                    map! {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-map-21" title="Link to this method">
                  <span class="method-callseq">
                    map! &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>With a block given, calls the block with each element of <code>self</code> and replaces the element with the block’s return value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span> } <span class="ruby-comment"># =&gt; [Symbol, String, Integer]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: <a href="Array.html#method-i-collect"><code>collect</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-collect-21">collect!</a>
        </div>
      </div>

      <div id="method-i-max" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-max" title="Link to this method">
                  <span class="method-callseq">
                    max &rarr; element
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-max" title="Link to this method">
                  <span class="method-callseq">
                    max(count) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-max" title="Link to this method">
                  <span class="method-callseq">
                    max {|a, b| ... } &rarr; element
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-max" title="Link to this method">
                  <span class="method-callseq">
                    max(count) {|a, b| ... } &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="max-source">
            <pre>static VALUE
rb_ary_max(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 1, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (UNDEF_P(result) || rb_cmpint(rb_yield_values(2, v, result), v, result) &gt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(INTEGER)) {
                return ary_max_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(STRING)) {
                return ary_max_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(FLOAT)) {
                return ary_max_opt_float(ary, 1, result);
            }
            else {
                return ary_max_generic(ary, 1, result);
            }
        }
    }
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre>
          </div>
          <p>Returns one of the following:</p>
<ul><li>
<p>The maximum-valued element from <code>self</code>.</p>
</li><li>
<p>A new array of maximum-valued elements from <code>self</code>.</p>
</li></ul>

<p>Does not modify <code>self</code>.</p>

<p>With no block given, each element in <code>self</code> must respond to method <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> with a numeric.</p>

<p>With no argument and no block, returns the element in <code>self</code> having the maximum value per method <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">max</span> <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>With non-negative numeric argument <code>count</code> and no block, returns a new array with at most <code>count</code> elements, in descending order, per method <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">3</span>)   <span class="ruby-comment"># =&gt; [3, 2, 1]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">3.0</span>) <span class="ruby-comment"># =&gt; [3, 2, 1]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">9</span>)   <span class="ruby-comment"># =&gt; [3, 2, 1, 0]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>With a block given, the block must return a numeric.</p>

<p>With a block and no argument, calls the block <code>self.size - 1</code> times to compare elements; returns the element having the maximum value per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>].<span class="ruby-identifier">max</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> }
<span class="ruby-comment"># =&gt; &quot;000&quot;</span>
</pre>

<p>With non-negative numeric argument <code>count</code> and a block, returns a new array with at most <code>count</code> elements, in descending order, per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>].<span class="ruby-identifier">max</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> }
<span class="ruby-comment"># =&gt; [&quot;000&quot;, &quot;00&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-min" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-min" title="Link to this method">
                  <span class="method-callseq">
                    min &rarr; element
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-min" title="Link to this method">
                  <span class="method-callseq">
                    min(count) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-min" title="Link to this method">
                  <span class="method-callseq">
                    min {|a, b| ... } &rarr; element
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-min" title="Link to this method">
                  <span class="method-callseq">
                    min(count) {|a, b| ... } &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="min-source">
            <pre>static VALUE
rb_ary_min(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 0, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (UNDEF_P(result) || rb_cmpint(rb_yield_values(2, v, result), v, result) &lt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(INTEGER)) {
                return ary_min_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(STRING)) {
                return ary_min_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(FLOAT)) {
                return ary_min_opt_float(ary, 1, result);
            }
            else {
                return ary_min_generic(ary, 1, result);
            }
        }
    }
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre>
          </div>
          <p>Returns one of the following:</p>
<ul><li>
<p>The minimum-valued element from <code>self</code>.</p>
</li><li>
<p>A new array of minimum-valued elements from <code>self</code>.</p>
</li></ul>

<p>Does not modify <code>self</code>.</p>

<p>With no block given, each element in <code>self</code> must respond to method <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> with a numeric.</p>

<p>With no argument and no block, returns the element in <code>self</code> having the minimum value per method <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">min</span> <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>With non-negative numeric argument <code>count</code> and no block, returns a new array with at most <code>count</code> elements, in ascending order, per method <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">3</span>)   <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">3.0</span>) <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">9</span>)   <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>With a block given, the block must return a numeric.</p>

<p>With a block and no argument, calls the block <code>self.size - 1</code> times to compare elements; returns the element having the minimum value per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>].<span class="ruby-identifier">min</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> }
<span class="ruby-comment"># =&gt; &quot;&quot;</span>
</pre>

<p>With non-negative numeric argument <code>count</code> and a block, returns a new array with at most <code>count</code> elements, in ascending order, per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>].<span class="ruby-identifier">min</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> }
<span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;0&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-minmax" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-minmax" title="Link to this method">
                  <span class="method-callseq">
                    minmax &rarr; array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-minmax" title="Link to this method">
                  <span class="method-callseq">
                    minmax {|a, b| ... } &rarr; array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="minmax-source">
            <pre>static VALUE
rb_ary_minmax(VALUE ary)
{
    if (rb_block_given_p()) {
        return rb_call_super(0, NULL);
    }
    return rb_assoc_new(rb_ary_min(0, 0, ary), rb_ary_max(0, 0, ary));
}</pre>
          </div>
          <p>Returns a 2-element array containing the minimum-valued and maximum-valued elements from <code>self</code>; does not modify <code>self</code>.</p>

<p>With no block given, the minimum and maximum values are determined using method <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p>

<pre class="ruby">[<span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">minmax</span> <span class="ruby-comment"># =&gt; [0, 3]</span>
</pre>

<p>With a block given, the block must return a numeric; the block is called <code>self.size - 1</code> times to compare elements; returns the elements having the minimum and maximum values per the block:</p>

<pre class="ruby">[<span class="ruby-string">&#39;0&#39;</span>, <span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39;000&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>].<span class="ruby-identifier">minmax</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">size</span> }
<span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;000&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-none-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-none-3F" title="Link to this method">
                  <span class="method-callseq">
                    none? &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-none-3F" title="Link to this method">
                  <span class="method-callseq">
                    none?(object) &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-none-3F" title="Link to this method">
                  <span class="method-callseq">
                    none? {|element| ... } &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="none-3F-source">
            <pre>static VALUE
rb_ary_none_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre>
          </div>
          <p>Returns <code>true</code> if no element of <code>self</code> meets a given criterion, <code>false</code> otherwise.</p>

<p>With no block given and no argument, returns <code>true</code> if <code>self</code> has no truthy elements, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">none?</span>    <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">false</span>].<span class="ruby-identifier">none?</span> <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">none?</span>              <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>With argument <code>object</code> given, returns <code>false</code> if for any element <code>element</code>, <code>object === element</code>; <code>true</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-regexp">/bar/</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">none?</span>(<span class="ruby-regexp">/foo/</span>)                <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span>(<span class="ruby-value">1</span>)             <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With a block given, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns no truthy value, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">none?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-one-3F" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-one-3F" title="Link to this method">
                  <span class="method-callseq">
                    one? &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-one-3F" title="Link to this method">
                  <span class="method-callseq">
                    one? {|element| ... } &rarr; true or false
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-one-3F" title="Link to this method">
                  <span class="method-callseq">
                    one?(object) &rarr; true or false
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="one-3F-source">
            <pre>static VALUE
rb_ary_one_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);
    VALUE result = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    return result;
}</pre>
          </div>
          <p>Returns <code>true</code> if exactly one element of <code>self</code> meets a given criterion.</p>

<p>With no block given and no argument, returns <code>true</code> if <code>self</code> has exactly one truthy element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-keyword">nil</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; false</span>
[].<span class="ruby-identifier">one?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With a block given, calls the block with each element in <code>self</code>; returns <code>true</code> if the block a truthy value for exactly one element, <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> } <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> } <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With argument <code>object</code> given, returns <code>true</code> if for exactly one element <code>element</code>, <code>object === element</code>; <code>false</code> otherwise:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; true</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-regexp">/bar/</span>) <span class="ruby-comment"># =&gt; false</span>
[<span class="ruby-string">&#39;food&#39;</span>, <span class="ruby-string">&#39;drink&#39;</span>].<span class="ruby-identifier">one?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; true</span>
[].<span class="ruby-identifier">one?</span>(<span class="ruby-regexp">/foo/</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-pack" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-pack" title="Link to this method">
                  <span class="method-callseq">
                    pack(template, buffer: nil) &rarr; string
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="pack-source">
            <pre><span class="ruby-comment"># File pack.rb, line 7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pack</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-value">buffer:</span> <span class="ruby-keyword">nil</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">pack_pack</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-identifier">buffer</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Formats each element in <code>self</code> into a binary string; returns that string. See <a href="packed_data_rdoc.html">Packed Data</a>.</p>
        </div>


      </div>

      <div id="method-i-permutation" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-permutation" title="Link to this method">
                  <span class="method-callseq">
                    permutation(count = self.size) {|permutation| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-permutation" title="Link to this method">
                  <span class="method-callseq">
                    permutation(count = self.size) &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="permutation-source">
            <pre>static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_permutation_size);   /* Return enumerator if no block */
    r = n;
    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0]))
        r = NUM2LONG(argv[0]);            /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r+roomof(n, sizeof(long)));
        char *used = (char*)(p + r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        MEMZERO(used, char, n); /* initialize array */

        permute0(n, r, p, used, ary0); /* compute and yield permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
          <p>Iterates over permutations of the elements of <code>self</code>; the order of permutations is indeterminate.</p>

<p>With a block and an in-range positive integer argument <code>count</code> (<code>0 &lt; count &lt;= self.size</code>) given, calls the block with each permutation of <code>self</code> of size <code>count</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">perms</span> = []
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">perm</span><span class="ruby-operator">|</span> <span class="ruby-identifier">perms</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">perm</span>) }
<span class="ruby-identifier">perms</span> <span class="ruby-comment"># =&gt; [[0], [1], [2]]</span>

<span class="ruby-identifier">perms</span> = []
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">perm</span><span class="ruby-operator">|</span> <span class="ruby-identifier">perms</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">perm</span>) }
<span class="ruby-identifier">perms</span> <span class="ruby-comment"># =&gt; [[0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1]]</span>

<span class="ruby-identifier">perms</span> = []
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">perm</span><span class="ruby-operator">|</span> <span class="ruby-identifier">perms</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">perm</span>) }
<span class="ruby-identifier">perms</span> <span class="ruby-comment"># =&gt; [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]</span>
</pre>

<p>When <code>count</code> is zero, calls the block once with a new empty array:</p>

<pre class="ruby"><span class="ruby-identifier">perms</span> = []
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">perm</span><span class="ruby-operator">|</span> <span class="ruby-identifier">perms</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">perm</span>) }
<span class="ruby-identifier">perms</span> <span class="ruby-comment"># =&gt; [[]]</span>
</pre>

<p>When <code>count</code> is out of range (negative or larger than <code>self.size</code>), does not call the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">4</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: <a href="Array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p>
        </div>


      </div>

      <div id="method-i-pop" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-pop" title="Link to this method">
                  <span class="method-callseq">
                    pop &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-pop" title="Link to this method">
                  <span class="method-callseq">
                    pop(count) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="pop-source">
            <pre>static VALUE
rb_ary_pop_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;

    if (argc == 0) {
        return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
    ary_verify(ary);
    return result;
}</pre>
          </div>
          <p>Removes and returns trailing elements of <code>self</code>.</p>

<p>With no argument given, removes and returns the last element, if available; otherwise returns <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>  <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>      <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
[].<span class="ruby-identifier">pop</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With non-negative integer argument <code>count</code> given, returns a new array containing the trailing <code>count</code> elements of <code>self</code>, as available:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>        <span class="ruby-comment"># =&gt; [:foo]</span>

<span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>         <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>Related: <a href="Array.html#method-i-push"><code>Array#push</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-prepend" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-prepend" title="Link to this method">
                  <span class="method-callseq">
                    prepend(*objects) &rarr; self
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>Prepends the given <code>objects</code> to <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">:bam</span>, <span class="ruby-value">:bat</span>) <span class="ruby-comment"># =&gt; [:bam, :bat, :foo, &quot;bar&quot;, 2]</span>
</pre>

<p>Related: <a href="Array.html#method-i-shift"><code>Array#shift</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-unshift">unshift</a>
        </div>
      </div>

      <div id="method-i-product" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-product" title="Link to this method">
                  <span class="method-callseq">
                    product(*other_arrays) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-product" title="Link to this method">
                  <span class="method-callseq">
                    product(*other_arrays) {|combination| ... } &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="product-source">
            <pre>static VALUE
rb_ary_product(int argc, VALUE *argv, VALUE ary)
{
    int n = argc+1;    /* How many arrays we&#39;re operating on */
    volatile VALUE t0 = rb_ary_hidden_new(n);
    volatile VALUE t1 = Qundef;
    VALUE *arrays = RARRAY_PTR(t0); /* The arrays we&#39;re computing the product of */
    int *counters = ALLOCV_N(int, t1, n); /* The current position in each one */
    VALUE result = Qnil;      /* The array we&#39;ll be returning, when no block given */
    long i,j;
    long resultlen = 1;

    RBASIC_CLEAR_CLASS(t0);

    /* initialize the arrays of arrays */
    ARY_SET_LEN(t0, n);
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = Qnil;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);

    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Otherwise, allocate and fill in an array of results */
    if (rb_block_given_p()) {
        /* Make defensive copies of arrays; exit if any is empty */
        for (i = 0; i &lt; n; i++) {
            if (RARRAY_LEN(arrays[i]) == 0) goto done;
            arrays[i] = ary_make_shared_copy(arrays[i]);
        }
    }
    else {
        /* Compute the length of the result array; return [] if any is empty */
        for (i = 0; i &lt; n; i++) {
            long k = RARRAY_LEN(arrays[i]);
            if (k == 0) {
                result = rb_ary_new2(0);
                goto done;
            }
            if (MUL_OVERFLOW_LONG_P(resultlen, k))
                rb_raise(rb_eRangeError, &quot;too big to product&quot;);
            resultlen *= k;
        }
        result = rb_ary_new2(resultlen);
    }
    for (;;) {
        int m;
        /* fill in one subarray */
        VALUE subarray = rb_ary_new2(n);
        for (j = 0; j &lt; n; j++) {
            rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
        }

        /* put it on the result array */
        if (NIL_P(result)) {
            FL_SET(t0, RARRAY_SHARED_ROOT_FLAG);
            rb_yield(subarray);
            if (!FL_TEST(t0, RARRAY_SHARED_ROOT_FLAG)) {
                rb_raise(rb_eRuntimeError, &quot;product reentered&quot;);
            }
            else {
                FL_UNSET(t0, RARRAY_SHARED_ROOT_FLAG);
            }
        }
        else {
            rb_ary_push(result, subarray);
        }

        /*
         * Increment the last counter.  If it overflows, reset to 0
         * and increment the one before it.
         */
        m = n-1;
        counters[m]++;
        while (counters[m] == RARRAY_LEN(arrays[m])) {
            counters[m] = 0;
            /* If the first counter overflows, we are done */
            if (--m &lt; 0) goto done;
            counters[m]++;
        }
    }

done:
    ALLOCV_END(t1);

    return NIL_P(result) ? ary : result;
}</pre>
          </div>
          <p>Computes all combinations of elements from all the arrays, including both <code>self</code> and <code>other_arrays</code>:</p>
<ul><li>
<p>The number of combinations is the product of the sizes of all the arrays, including both <code>self</code> and <code>other_arrays</code>.</p>
</li><li>
<p>The order of the returned combinations is indeterminate.</p>
</li></ul>

<p>With no block given, returns the combinations as an array of arrays:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>])
<span class="ruby-comment"># =&gt; [[0, 2], [0, 3], [1, 2], [1, 3]]</span>
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-identifier">p</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>])
<span class="ruby-comment"># =&gt; [[0, 2, 4], [0, 2, 5], [0, 3, 4], [0, 3, 5], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3,...</span>
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 8</span>
</pre>

<p>If <code>self</code> or any argument is empty, returns an empty array:</p>

<pre class="ruby">[].<span class="ruby-identifier">product</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]) <span class="ruby-comment"># =&gt; []</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], []) <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>If no argument is given, returns an array of 1-element arrays, each containing an element of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">product</span> <span class="ruby-comment"># =&gt; [[0], [1], [2]]</span>
</pre>

<p>With a block given, calls the block with each combination; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">combination</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-comment"># =&gt; [[0, 2], [0, 3], [1, 2], [1, 3]]</span>
</pre>

<p>If <code>self</code> or any argument is empty, does not call the block:</p>

<pre class="ruby">[].<span class="ruby-identifier">product</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-comment"># =&gt; []</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], []) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-comment"># =&gt; [0, 1]</span>
</pre>

<p>If no argument is given, calls the block with each element of <code>self</code> as a 1-element array:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">product</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">combination</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-comment"># =&gt; [[0], [1]]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-push" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-push" title="Link to this method">
                  <span class="method-callseq">
                    push(*objects) &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="push-source">
            <pre>static VALUE
rb_ary_push_m(int argc, VALUE *argv, VALUE ary)
{
    return rb_ary_cat(ary, argv, argc);
}</pre>
          </div>
          <p>Appends each argument in <code>objects</code> to <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>)   <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, :baz, :bat]</span>
</pre>

<p>Appends each argument as a single element, even if it is another array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]               <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>([<span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span>], [<span class="ruby-value">:bam</span>, <span class="ruby-value">:bad</span>]) <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2, [:baz, :bat], [:bam, :bad]]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-append">append</a>
        </div>

      </div>

      <div id="method-i-rassoc" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-rassoc" title="Link to this method">
                  <span class="method-callseq">
                    rassoc(object) &rarr; found_array or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="rassoc-source">
            <pre>VALUE
rb_ary_rassoc(VALUE ary, VALUE value)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (RB_TYPE_P(v, T_ARRAY) &amp;&amp;
            RARRAY_LEN(v) &gt; 1 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 1), value))
            return v;
    }
    return Qnil;
}</pre>
          </div>
          <p>Returns the first element <code>ele</code> in <code>self</code> such that <code>ele</code> is an array and <code>ele[1] == object</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}, [<span class="ruby-value">2</span>, <span class="ruby-value">4</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; [2, 4]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-value">5</span>) <span class="ruby-comment"># =&gt; [4, 5, 6]</span>
</pre>

<p>Returns <code>nil</code> if no such element is found.</p>

<p>Related: <a href="Array.html#method-i-assoc"><code>Array#assoc</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-reject" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-reject" title="Link to this method">
                  <span class="method-callseq">
                    reject {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-reject" title="Link to this method">
                  <span class="method-callseq">
                    reject &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="reject-source">
            <pre>static VALUE
rb_ary_reject(VALUE ary)
{
    VALUE rejected_ary;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rejected_ary = rb_ary_new();
    ary_reject(ary, rejected_ary);
    return rejected_ary;
}</pre>
          </div>
          <p>With a block given, returns a new array whose elements are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bat&#39;</span>]
<span class="ruby-identifier">a1</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">a1</span> <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-reject-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-reject-21" title="Link to this method">
                  <span class="method-callseq">
                    reject! {|element| ... } &rarr; self or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-reject-21" title="Link to this method">
                  <span class="method-callseq">
                    reject! &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="reject-21-source">
            <pre>static VALUE
rb_ary_reject_bang(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    return ary_reject_bang(ary);
}</pre>
          </div>
          <p>With a block given, calls the block with each element of <code>self</code>; removes each element for which the block returns a truthy value.</p>

<p>Returns <code>self</code> if any elements removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bat&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reject!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [:foo, 2]</span>
</pre>

<p>Returns <code>nil</code> if no elements removed.</p>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-repeated_combination" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-repeated_combination" title="Link to this method">
                  <span class="method-callseq">
                    repeated_combination(size) {|combination| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-repeated_combination" title="Link to this method">
                  <span class="method-callseq">
                    repeated_combination(size) &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="repeated_combination-source">
            <pre>static VALUE
rb_ary_repeated_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);                 /* Combination size from argument */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_combination_size);   /* Return enumerator if no block */
    len = RARRAY_LEN(ary);
    if (n &lt; 0) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else if (len == 0) {
        /* yield nothing */
    }
    else {
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, n);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rcombinate0(len, n, p, n, ary0); /* compute and yield repeated combinations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
          <p>With a block given, calls the block with each repeated combination of length <code>size</code> of the elements of <code>self</code>; each combination is an array; returns <code>self</code>. The order of the combinations is indeterminate.</p>

<p>If a positive integer argument <code>size</code> is given, calls the block with each <code>size</code>-tuple repeated combination of the elements of <code>self</code>. The number of combinations is <code>(size+1)(size+2)/2</code>.</p>

<p>Examples:</p>
<ul><li>
<p><code>size</code> is 1:</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">combination</span>) }
<span class="ruby-identifier">c</span> <span class="ruby-comment"># =&gt; [[0], [1], [2]]</span>
</pre>
</li><li>
<p><code>size</code> is 2:</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">combination</span>) }
<span class="ruby-identifier">c</span> <span class="ruby-comment"># =&gt; [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]</span>
</pre>
</li></ul>

<p>If <code>size</code> is zero, calls the block once with an empty array.</p>

<p>If <code>size</code> is negative, does not call the block:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">combination</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-repeated_permutation" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-repeated_permutation" title="Link to this method">
                  <span class="method-callseq">
                    repeated_permutation(size) {|permutation| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-repeated_permutation" title="Link to this method">
                  <span class="method-callseq">
                    repeated_permutation(size) &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="repeated_permutation-source">
            <pre>static VALUE
rb_ary_repeated_permutation(VALUE ary, VALUE num)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_permutation_size);      /* Return Enumerator if no block */
    r = NUM2LONG(num);                    /* Permutation size from argument */

    if (r &lt; 0) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rpermute0(n, r, p, ary0); /* compute and yield repeated permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre>
          </div>
          <p>With a block given, calls the block with each repeated permutation of length <code>size</code> of the elements of <code>self</code>; each permutation is an array; returns <code>self</code>. The order of the permutations is indeterminate.</p>

<p>If a positive integer argument <code>size</code> is given, calls the block with each <code>size</code>-tuple repeated permutation of the elements of <code>self</code>. The number of permutations is <code>self.size**size</code>.</p>

<p>Examples:</p>
<ul><li>
<p><code>size</code> is 1:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">permutation</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-comment"># =&gt; [[0], [1], [2]]</span>
</pre>
</li><li>
<p><code>size</code> is 2:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">permutation</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-comment"># =&gt; [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span>
</pre>
</li></ul>

<p>If <code>size</code> is zero, calls the block once with an empty array.</p>

<p>If <code>size</code> is negative, does not call the block:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">-1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">permutation</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-replace" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-replace" title="Link to this method">
                  <span class="method-callseq">
                    replace(other_array) &rarr; self
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>Replaces the elements of <code>self</code> with the elements of <code>other_array</code>, which must be an <a href="implicit_conversion_rdoc.html#label-Array-Convertible+Objects">array-convertible object</a>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>]   <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([<span class="ruby-string">&#39;d&#39;</span>, <span class="ruby-string">&#39;e&#39;</span>]) <span class="ruby-comment"># =&gt; [&quot;d&quot;, &quot;e&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-initialize_copy">initialize_copy</a>
        </div>
      </div>

      <div id="method-i-reverse" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-reverse" title="Link to this method">
                  <span class="method-callseq">
                    reverse &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="reverse-source">
            <pre>static VALUE
rb_ary_reverse_m(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE dup = rb_ary_new2(len);

    if (len &gt; 0) {
        const VALUE *p1 = RARRAY_CONST_PTR(ary);
        VALUE *p2 = (VALUE *)RARRAY_CONST_PTR(dup) + len - 1;
        do *p2-- = *p1++; while (--len &gt; 0);
    }
    ARY_SET_LEN(dup, RARRAY_LEN(ary));
    return dup;
}</pre>
          </div>
          <p>Returns a new array containing the elements of <code>self</code> in reverse order:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">reverse</span> <span class="ruby-comment"># =&gt; [2, 1, 0]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-reverse-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-reverse-21" title="Link to this method">
                  <span class="method-callseq">
                    reverse! &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="reverse-21-source">
            <pre>static VALUE
rb_ary_reverse_bang(VALUE ary)
{
    return rb_ary_reverse(ary);
}</pre>
          </div>
          <p>Reverses the order of the elements of <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse!</span> <span class="ruby-comment"># =&gt; [2, 1, 0]</span>
<span class="ruby-identifier">a</span>          <span class="ruby-comment"># =&gt; [2, 1, 0]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-reverse_each" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-reverse_each" title="Link to this method">
                  <span class="method-callseq">
                    reverse_each {|element| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-reverse_each" title="Link to this method">
                  <span class="method-callseq">
                    reverse_each &rarr; Enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="reverse_each-source">
            <pre>static VALUE
rb_ary_reverse_each(VALUE ary)
{
    long len;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }
    return ary;
}</pre>
          </div>
          <p>When a block given, iterates backwards over the elements of <code>self</code>, passing, in reverse order, each element to the block; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = []
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">element</span>) }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [2, 1, 0]</span>
</pre>

<p>Allows the array to be modified during iteration:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>When no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p>
        </div>


      </div>

      <div id="method-i-rindex" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-rindex" title="Link to this method">
                  <span class="method-callseq">
                    rindex(object) &rarr; integer or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-rindex" title="Link to this method">
                  <span class="method-callseq">
                    rindex {|element| ... } &rarr; integer or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-rindex" title="Link to this method">
                  <span class="method-callseq">
                    rindex &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="rindex-source">
            <pre>static VALUE
rb_ary_rindex(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i = RARRAY_LEN(ary), len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        while (i--) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i))))
                return LONG2NUM(i);
            if (i &gt; (len = RARRAY_LEN(ary))) {
                i = len;
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    while (i--) {
        VALUE e = RARRAY_AREF(ary, i);
        if (rb_equal(e, val)) {
            return LONG2NUM(i);
        }
        if (i &gt; RARRAY_LEN(ary)) {
            break;
        }
    }
    return Qnil;
}</pre>
          </div>
          <p>Returns the index of the last element for which <code>object == element</code>.</p>

<p>With argument <code>object</code> given, returns the index of the last such element found:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>Returns <code>nil</code> if no such object found.</p>

<p>With a block given, calls the block with each successive element; returns the index of the last element for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;bar&#39;</span> } <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>Returns <code>nil</code> if the block never returns a truthy value.</p>

<p>When neither an argument nor a block is given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


      </div>

      <div id="method-i-rotate" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-rotate" title="Link to this method">
                  <span class="method-callseq">
                    rotate(count = 1) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="rotate-source">
            <pre>static VALUE
rb_ary_rotate_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE rotated;
    const VALUE *ptr;
    long len;
    long cnt = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);

    len = RARRAY_LEN(ary);
    rotated = rb_ary_new2(len);
    if (len &gt; 0) {
        cnt = rotate_count(cnt, len);
        ptr = RARRAY_CONST_PTR(ary);
        len -= cnt;
        ary_memcpy(rotated, 0, len, ptr + cnt);
        ary_memcpy(rotated, len, cnt, ptr);
    }
    ARY_SET_LEN(rotated, RARRAY_LEN(ary));
    return rotated;
}</pre>
          </div>
          <p>Returns a new array formed from <code>self</code> with elements rotated from one end to the other.</p>

<p>With non-negative numeric <code>count</code>, rotates elements from the beginning to the end:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; [2, 3, 0, 1]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate</span>(<span class="ruby-value">2.1</span>) <span class="ruby-comment"># =&gt; [2, 3, 0, 1]</span>
</pre>

<p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate</span>(<span class="ruby-value">22</span>) <span class="ruby-comment"># =&gt; [2, 3, 0, 1]</span>
</pre>

<p>With a <code>count</code> of zero, rotates no elements:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>With negative numeric <code>count</code>, rotates in the opposite direction, from the end to the beginning:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [3, 0, 1, 2]</span>
</pre>

<p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate</span>(<span class="ruby-value">-21</span>) <span class="ruby-comment"># =&gt; [3, 0, 1, 2]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-rotate-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-rotate-21" title="Link to this method">
                  <span class="method-callseq">
                    rotate!(count = 1) &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="rotate-21-source">
            <pre>static VALUE
rb_ary_rotate_bang(int argc, VALUE *argv, VALUE ary)
{
    long n = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);
    rb_ary_rotate(ary, n);
    return ary;
}</pre>
          </div>
          <p>Rotates <code>self</code> in place by moving elements from one end to the other; returns <code>self</code>.</p>

<p>With non-negative numeric <code>count</code>, rotates <code>count</code> elements from the beginning to the end:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; [2, 3, 0, 1]</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">2.1</span>) <span class="ruby-comment"># =&gt; [2, 3, 0, 1]</span>
</pre>

<p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">21</span>) <span class="ruby-comment"># =&gt; [1, 2, 3, 0]</span>
</pre>

<p>If <code>count</code> is zero, rotates no elements:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>With a negative numeric <code>count</code>, rotates in the opposite direction, from end to beginning:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [3, 0, 1, 2]</span>
</pre>

<p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">-21</span>) <span class="ruby-comment"># =&gt; [3, 0, 1, 2]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-sample" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-sample" title="Link to this method">
                  <span class="method-callseq">
                    sample(random: Random) &rarr; object
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-sample" title="Link to this method">
                  <span class="method-callseq">
                    sample(count, random: Random) &rarr; new_ary
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="sample-source">
            <pre><span class="ruby-comment"># File array.rb, line 95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample</span>(<span class="ruby-identifier">n</span> = (<span class="ruby-identifier">ary</span> = <span class="ruby-keyword">false</span>), <span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">mandatory_only?</span>
    <span class="ruby-comment"># Primitive.cexpr! %{ rb_ary_sample(self, rb_cRandom, Qfalse, Qfalse) }</span>
    <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">ary_sample0</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Primitive.cexpr! %{ rb_ary_sample(self, random, n, ary) }</span>
    <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">ary_sample</span>(<span class="ruby-identifier">random</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">ary</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Returns random elements from <code>self</code>, as selected by the object given by the keyword argument <code>random</code>.</p>

<p>With no argument <code>count</code> given, returns one random element from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span> <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span> <span class="ruby-comment"># =&gt; 8</span>
</pre>

<p>Returns <code>nil</code> if <code>self</code> is empty:</p>

<pre class="ruby">[].<span class="ruby-identifier">sample</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With a non-negative numeric argument <code>count</code> given, returns a new array containing <code>count</code> random elements from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [8, 9, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">6</span>) <span class="ruby-comment"># =&gt; [9, 6, 0, 3, 1, 4]</span>
</pre>

<p>The order of the result array is unrelated to the order of <code>self</code>.</p>

<p>Returns a new empty <a href="Array.html"><code>Array</code></a> if <code>self</code> is empty:</p>

<pre class="ruby">[].<span class="ruby-identifier">sample</span>(<span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>May return duplicates in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-identifier">a</span>.<span class="ruby-identifier">size</span>) <span class="ruby-comment"># =&gt; [1, 1, 3, 2, 1, 2]</span>
</pre>

<p>Returns no more than <code>a.size</code> elements (because no new duplicates are introduced):</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [6, 4, 1, 8, 5, 9, 0, 2, 3, 7]</span>
</pre>

<p>The object given with the keyword argument <code>random</code> is used as the random number generator:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))     <span class="ruby-comment"># =&gt; 6</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">4</span>, <span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))  <span class="ruby-comment"># =&gt; [6, 10, 9, 2]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-select" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-select" title="Link to this method">
                  <span class="method-callseq">
                    select {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-select" title="Link to this method">
                  <span class="method-callseq">
                    select &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="select-source">
            <pre>static VALUE
rb_ary_select(VALUE ary)
{
    VALUE result;
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    result = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
    }
    return result;
}</pre>
          </div>
          <p>With a block given, calls the block with each element of <code>self</code>; returns a new array containing those elements of <code>self</code> for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-filter">filter</a>, filter
        </div>

      </div>

      <div id="method-i-select-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-select-21" title="Link to this method">
                  <span class="method-callseq">
                    select! {|element| ... } &rarr; self or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-select-21" title="Link to this method">
                  <span class="method-callseq">
                    select! &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="select-21-source">
            <pre>static VALUE
rb_ary_select_bang(VALUE ary)
{
    struct select_bang_arg args;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);

    args.ary = ary;
    args.len[0] = args.len[1] = 0;
    return rb_ensure(select_bang_i, (VALUE)&amp;args, select_bang_ensure, (VALUE)&amp;args);
}</pre>
          </div>
          <p>With a block given, calls the block with each element of <code>self</code>; removes from <code>self</code> those elements for which the block returns <code>false</code> or <code>nil</code>.</p>

<p>Returns <code>self</code> if any elements were removed:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">:bam</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; [&quot;bar&quot;, :bam]</span>
</pre>

<p>Returns <code>nil</code> if no elements were removed.</p>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-filter-21">filter!</a>
        </div>

      </div>

      <div id="method-i-shelljoin" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-shelljoin" title="Link to this method">
                  <span class="method-callseq">
                    shelljoin &rarr; string
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="shelljoin-source">
            <pre><span class="ruby-comment"># File lib/shellwords.rb, line 251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shelljoin</span>
  <span class="ruby-constant">Shellwords</span>.<span class="ruby-identifier">join</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Builds a command line string from an argument list <code>array</code> joining all elements escaped for the Bourne shell and separated by a space.</p>

<p>See <a href="Shellwords.html#method-c-shelljoin"><code>Shellwords.shelljoin</code></a> for details.</p>
        </div>


      </div>

      <div id="method-i-shift" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-shift" title="Link to this method">
                  <span class="method-callseq">
                    shift &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-shift" title="Link to this method">
                  <span class="method-callseq">
                    shift(count) &rarr; new_array or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="shift-source">
            <pre>static VALUE
rb_ary_shift_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;
    long n;

    if (argc == 0) {
        return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    n = RARRAY_LEN(result);
    rb_ary_behead(ary,n);

    return result;
}</pre>
          </div>
          <p>Removes and returns leading elements from <code>self</code>.</p>

<p>With no argument, removes and returns one element, if available, or <code>nil</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span>  <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">a</span>        <span class="ruby-comment"># =&gt; [1, 2, 3]</span>
[].<span class="ruby-identifier">shift</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With non-negative numeric argument <code>count</code> given, removes and returns the first <code>count</code> elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; [0, 1]</span>
<span class="ruby-identifier">a</span>            <span class="ruby-comment"># =&gt; [2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">1.1</span>) <span class="ruby-comment"># =&gt; [2]</span>
<span class="ruby-identifier">a</span>            <span class="ruby-comment"># =&gt; [3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-identifier">a</span>            <span class="ruby-comment"># =&gt; [3]</span>
</pre>

<p>If <code>count</code> is large, removes and returns all elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
<span class="ruby-identifier">a</span>           <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>If <code>self</code> is empty, returns a new empty array.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-shuffle" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-shuffle" title="Link to this method">
                  <span class="method-callseq">
                    shuffle(random: Random) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="shuffle-source">
            <pre><span class="ruby-comment"># File array.rb, line 45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuffle</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">rb_ary_shuffle</span>(<span class="ruby-identifier">random</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Returns a new array containing all elements from <code>self</code> in a random order, as selected by the object given by the keyword argument <code>random</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> =            [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span> <span class="ruby-comment"># =&gt; [0, 8, 1, 9, 6, 3, 4, 7, 2, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span> <span class="ruby-comment"># =&gt; [8, 9, 0, 5, 1, 2, 6, 4, 7, 3]</span>
</pre>

<p>Duplicate elements are included:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> =            [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span> <span class="ruby-comment"># =&gt; [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span> <span class="ruby-comment"># =&gt; [1, 1, 0, 0, 0, 1, 1, 0, 0, 1]</span>
</pre>

<p>The object given with the keyword argument <code>random</code> is used as the random number generator.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-shuffle-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-shuffle-21" title="Link to this method">
                  <span class="method-callseq">
                    shuffle!(random: Random) &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="shuffle-21-source">
            <pre><span class="ruby-comment"># File array.rb, line 22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuffle!</span>(<span class="ruby-value">random:</span> <span class="ruby-constant">Random</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">rb_ary_shuffle_bang</span>(<span class="ruby-identifier">random</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          <p>Shuffles all elements in <code>self</code> into a random order, as selected by the object given by the keyword argument <code>random</code>. Returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> =             [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span> <span class="ruby-comment"># =&gt; [5, 3, 8, 7, 6, 1, 9, 4, 2, 0]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span> <span class="ruby-comment"># =&gt; [9, 4, 0, 6, 2, 8, 1, 5, 3, 7]</span>
</pre>

<p>Duplicate elements are included:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> =             [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span> <span class="ruby-comment"># =&gt; [1, 0, 0, 1, 1, 0, 1, 0, 0, 1]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span> <span class="ruby-comment"># =&gt; [0, 1, 0, 1, 1, 0, 1, 0, 1, 0]</span>
</pre>

<p>The object given with the keyword argument <code>random</code> is used as the random number generator.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-size" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-size" title="Link to this method">
                  <span class="method-callseq">
                    size &rarr; integer
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>Returns the count of elements in <code>self</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">length</span> <span class="ruby-comment"># =&gt; 3</span>
[].<span class="ruby-identifier">length</span>        <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-length">length</a>
        </div>
      </div>

      <div id="method-i-slice" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-slice" title="Link to this method">
                  <span class="method-callseq">
                    slice(index) &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-slice" title="Link to this method">
                  <span class="method-callseq">
                    slice(start, length) &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-slice" title="Link to this method">
                  <span class="method-callseq">
                    slice(range) &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-slice" title="Link to this method">
                  <span class="method-callseq">
                    slice(aseq) &rarr; object or nil
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p>

<p>In brief:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]

<span class="ruby-comment"># Single argument index: returns one element.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>]     <span class="ruby-comment"># =&gt; :foo          # Zero-based index.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>]    <span class="ruby-comment"># =&gt; 2             # Negative index counts backwards from end.</span>

<span class="ruby-comment"># Arguments start and length: returns an array.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]  <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]    # Negative start counts backwards from end.</span>

<span class="ruby-comment"># Single argument range: returns an array.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>]  <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;] # Negative range-begin counts backwards from end.</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]    # Negative range-end counts backwards from end.</span>
</pre>

<p>When a single integer argument <code>index</code> is given, returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>index</code> is negative, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

<p>If <code>index</code> is out of range, returns <code>nil</code>.</p>

<p>When two <a href="Integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given, returns a new <a href="Array.html"><code>Array</code></a> of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">4</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">3</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>, <span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
</pre>

<p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty <a href="Array.html"><code>Array</code></a>.</p>

<p>If <code>length</code> is negative, returns <code>nil</code>.</p>

<p>When a single <a href="Range.html"><code>Range</code></a> argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
</pre>

<p>Special case: If <code>range.start == a.size</code>, returns a new empty <a href="Array.html"><code>Array</code></a>.</p>

<p>If <code>range.end</code> is negative, calculates the end index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] <span class="ruby-comment"># =&gt; [:foo]</span>
</pre>

<p>If <code>range.start</code> is negative, calculates the start index from the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [&quot;bar&quot;, 2]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] <span class="ruby-comment"># =&gt; [:foo, &quot;bar&quot;, 2]</span>
</pre>

<p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>When a single <a href="Enumerator/ArithmeticSequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an <a href="Array.html"><code>Array</code></a> of elements corresponding to the indexes produced by the sequence.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)] <span class="ruby-comment"># =&gt; [&quot;data1&quot;, &quot;data2&quot;, &quot;data3&quot;]</span>
</pre>

<p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="RangeError.html"><code>RangeError</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data1&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data2&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;data3&#39;</span>]
<span class="ruby-identifier">a</span>[(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">11</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((1..11).step(2)) out of range)</span>
<span class="ruby-identifier">a</span>[(<span class="ruby-value">7</span><span class="ruby-operator">..</span>).<span class="ruby-identifier">step</span>(<span class="ruby-value">2</span>)]
<span class="ruby-comment"># RangeError (((7..).step(2)) out of range)</span>
</pre>

<p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="Integer.html"><code>Integer</code></a>, and raises if it is impossible:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-comment"># Raises TypeError (no implicit conversion of Symbol into Integer):</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">:foo</span>]
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-5B-5D">[]</a>
        </div>
      </div>

      <div id="method-i-slice-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-slice-21" title="Link to this method">
                  <span class="method-callseq">
                    slice!(index) &rarr; object or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-slice-21" title="Link to this method">
                  <span class="method-callseq">
                    slice!(start, length) &rarr; new_array or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-slice-21" title="Link to this method">
                  <span class="method-callseq">
                    slice!(range) &rarr; new_array or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="slice-21-source">
            <pre>static VALUE
rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg1;
    long pos, len;

    rb_ary_modify_check(ary);
    rb_check_arity(argc, 1, 2);
    arg1 = argv[0];

    if (argc == 2) {
        pos = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
    }

    if (!FIXNUM_P(arg1)) {
        switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
          case Qtrue:
            /* valid range */
            return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
          case Qnil:
            /* invalid range */
            return Qnil;
          default:
            /* not a range */
            break;
        }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}</pre>
          </div>
          <p>Removes and returns elements from <code>self</code>.</p>

<p>With numeric argument <code>index</code> given, removes and returns the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; &quot;c&quot;</span>
<span class="ruby-identifier">a</span>             <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">2.1</span>) <span class="ruby-comment"># =&gt; &quot;d&quot;</span>
<span class="ruby-identifier">a</span>             <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;]</span>
</pre>

<p>If <code>index</code> is negative, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; &quot;c&quot;</span>
<span class="ruby-identifier">a</span>            <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>index</code> is out of range, returns <code>nil</code>.</p>

<p>With numeric arguments <code>start</code> and <code>length</code> given, removes <code>length</code> elements from <code>self</code> beginning at zero-based offset <code>start</code>; returns the removed objects in a new array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>)     <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>                  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">0.1</span>, <span class="ruby-value">1.1</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;]</span>
<span class="ruby-identifier">a</span>                  <span class="ruby-comment"># =&gt; [&quot;d&quot;]</span>
</pre>

<p>If <code>start</code> is negative, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [&quot;c&quot;]</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>start</code> is out-of-range, returns <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">5</span>, <span class="ruby-value">1</span>)  <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-5</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>start + length</code> exceeds the array size, removes and returns all elements from offset <code>start</code> to the end:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">2</span>, <span class="ruby-value">50</span>) <span class="ruby-comment"># =&gt; [&quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;]</span>
</pre>

<p>If <code>start == a.size</code> and <code>length</code> is non-negative, returns a new empty array.</p>

<p>If <code>length</code> is negative, returns <code>nil</code>.</p>

<p>With <a href="Range.html"><code>Range</code></a> argument <code>range</code> given, treats <code>range.min</code> as <code>start</code> (as above) and <code>range.size</code> as <code>length</code> (as above):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>              <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;d&quot;]</span>
</pre>

<p>If <code>range.start == a.size</code>, returns a new empty array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>) <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>range.start</code> is negative, calculates the start index by counting backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;c&quot;]</span>
</pre>

<p>If <code>range.end</code> is negative, calculates the end index by counting backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-sort" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-sort" title="Link to this method">
                  <span class="method-callseq">
                    sort &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-sort" title="Link to this method">
                  <span class="method-callseq">
                    sort {|a, b| ... } &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="sort-source">
            <pre>VALUE
rb_ary_sort(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}</pre>
          </div>
          <p>Returns a new array containing the elements of <code>self</code>, sorted.</p>

<p>With no block given, compares elements using operator <a href="Array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> (see <a href="Object.html#method-i-3C-3D-3E"><code>Object#&lt;=&gt;</code></a>):</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">sort</span> <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>With a block given, calls the block with each combination of pairs of elements from <code>self</code>; for each pair <code>a</code> and <code>b</code>, the block should return a numeric:</p>
<ul><li>
<p>Negative when <code>b</code> is to follow <code>a</code>.</p>
</li><li>
<p>Zero when <code>a</code> and <code>b</code> are equivalent.</p>
</li><li>
<p>Positive when <code>a</code> is to follow <code>b</code>.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span> } <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">a</span> } <span class="ruby-comment"># =&gt; [3, 2, 1, 0]</span>
</pre>

<p>When the block returns zero, the order for <code>a</code> and <code>b</code> is indeterminate, and may be unstable.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-sort-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-sort-21" title="Link to this method">
                  <span class="method-callseq">
                    sort! &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-sort-21" title="Link to this method">
                  <span class="method-callseq">
                    sort! {|a, b| ... } &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="sort-21-source">
            <pre>VALUE
rb_ary_sort_bang(VALUE ary)
{
    rb_ary_modify(ary);
    RUBY_ASSERT(!ARY_SHARED_P(ary));
    if (RARRAY_LEN(ary) &gt; 1) {
        VALUE tmp = ary_make_substitution(ary); /* only ary refers tmp */
        struct ary_sort_data data;
        long len = RARRAY_LEN(ary);
        RBASIC_CLEAR_CLASS(tmp);
        data.ary = tmp;
        data.receiver = ary;
        RARRAY_PTR_USE(tmp, ptr, {
            ruby_qsort(ptr, len, sizeof(VALUE),
                       rb_block_given_p()?sort_1:sort_2, &amp;data);
        }); /* WB: no new reference */
        rb_ary_modify(ary);
        if (ARY_EMBED_P(tmp)) {
            if (ARY_SHARED_P(ary)) { /* ary might be destructively operated in the given block */
                rb_ary_unshare(ary);
                FL_SET_EMBED(ary);
            }
            if (ARY_EMBED_LEN(tmp) &gt; ARY_CAPA(ary)) {
                ary_resize_capa(ary, ARY_EMBED_LEN(tmp));
            }
            ary_memcpy(ary, 0, ARY_EMBED_LEN(tmp), ARY_EMBED_PTR(tmp));
            ARY_SET_LEN(ary, ARY_EMBED_LEN(tmp));
        }
        else {
            if (!ARY_EMBED_P(ary) &amp;&amp; ARY_HEAP_PTR(ary) == ARY_HEAP_PTR(tmp)) {
                FL_UNSET_SHARED(ary);
                ARY_SET_CAPA(ary, RARRAY_LEN(tmp));
            }
            else {
                RUBY_ASSERT(!ARY_SHARED_P(tmp));
                if (ARY_EMBED_P(ary)) {
                    FL_UNSET_EMBED(ary);
                }
                else if (ARY_SHARED_P(ary)) {
                    /* ary might be destructively operated in the given block */
                    rb_ary_unshare(ary);
                }
                else {
                    ary_heap_free(ary);
                }
                ARY_SET_PTR(ary, ARY_HEAP_PTR(tmp));
                ARY_SET_HEAP_LEN(ary, len);
                ARY_SET_CAPA(ary, ARY_HEAP_LEN(tmp));
            }
            /* tmp was lost ownership for the ptr */
            FL_UNSET(tmp, FL_FREEZE);
            FL_SET_EMBED(tmp);
            ARY_SET_EMBED_LEN(tmp, 0);
            FL_SET(tmp, FL_FREEZE);
        }
        /* tmp will be GC&#39;ed. */
        RBASIC_SET_CLASS_RAW(tmp, rb_cArray); /* rb_cArray must be marked */
    }
    ary_verify(ary);
    return ary;
}</pre>
          </div>
          <p>Like <a href="Array.html#method-i-sort"><code>Array#sort</code></a>, but returns <code>self</code> with its elements sorted in place.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-sort_by-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-sort_by-21" title="Link to this method">
                  <span class="method-callseq">
                    sort_by! {|element| ... } &rarr; self
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-sort_by-21" title="Link to this method">
                  <span class="method-callseq">
                    sort_by! &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="sort_by-21-source">
            <pre>static VALUE
rb_ary_sort_by_bang(VALUE ary)
{
    VALUE sorted;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    sorted = rb_block_call(ary, rb_intern(&quot;sort_by&quot;), 0, 0, sort_by_i, 0);
    rb_ary_replace(ary, sorted);
    return ary;
}</pre>
          </div>
          <p>With a block given, sorts the elements of <code>self</code> in place; returns self.</p>

<p>Calls the block with each successive element; sorts elements based on the values returned from the block:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;aaaa&#39;</span>, <span class="ruby-string">&#39;bbb&#39;</span>, <span class="ruby-string">&#39;cc&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort_by!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">size</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;d&quot;, &quot;cc&quot;, &quot;bbb&quot;, &quot;aaaa&quot;]</span>
</pre>

<p>For duplicate values returned by the block, the ordering is indeterminate, and may be unstable.</p>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>


      </div>

      <div id="method-i-sum" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-sum" title="Link to this method">
                  <span class="method-callseq">
                    sum(init = 0) &rarr; object
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-sum" title="Link to this method">
                  <span class="method-callseq">
                    sum(init = 0) {|element| ... } &rarr; object
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="sum-source">
            <pre>static VALUE
rb_ary_sum(int argc, VALUE *argv, VALUE ary)
{
    VALUE e, v, r;
    long i, n;
    int block_given;

    v = (rb_check_arity(argc, 0, 1) ? argv[0] : LONG2FIX(0));

    block_given = rb_block_given_p();

    if (RARRAY_LEN(ary) == 0)
        return v;

    n = 0;
    r = Qundef;

    if (!FIXNUM_P(v) &amp;&amp; !RB_BIGNUM_TYPE_P(v) &amp;&amp; !RB_TYPE_P(v, T_RATIONAL)) {
        i = 0;
        goto init_is_a_value;
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
        if (FIXNUM_P(e)) {
            n += FIX2LONG(e); /* should not overflow long type */
            if (!FIXABLE(n)) {
                v = rb_big_plus(LONG2NUM(n), v);
                n = 0;
            }
        }
        else if (RB_BIGNUM_TYPE_P(e))
            v = rb_big_plus(e, v);
        else if (RB_TYPE_P(e, T_RATIONAL)) {
            if (UNDEF_P(r))
                r = e;
            else
                r = rb_rational_plus(r, e);
        }
        else
            goto not_exact;
    }
    v = finish_exact_sum(n, r, v, argc!=0);
    return v;

  not_exact:
    v = finish_exact_sum(n, r, v, i!=0);

    if (RB_FLOAT_TYPE_P(e)) {
        /*
         * Kahan-Babuska balancing compensated summation algorithm
         * See https://link.springer.com/article/10.1007/s00607-005-0139-x
         */
        double f, c;
        double x, t;

        f = NUM2DBL(v);
        c = 0.0;
        goto has_float_value;
        for (; i &lt; RARRAY_LEN(ary); i++) {
            e = RARRAY_AREF(ary, i);
            if (block_given)
                e = rb_yield(e);
            if (RB_FLOAT_TYPE_P(e))
              has_float_value:
                x = RFLOAT_VALUE(e);
            else if (FIXNUM_P(e))
                x = FIX2LONG(e);
            else if (RB_BIGNUM_TYPE_P(e))
                x = rb_big2dbl(e);
            else if (RB_TYPE_P(e, T_RATIONAL))
                x = rb_num2dbl(e);
            else
                goto not_float;

            if (isnan(f)) continue;
            if (isnan(x)) {
                f = x;
                continue;
            }
            if (isinf(x)) {
                if (isinf(f) &amp;&amp; signbit(x) != signbit(f))
                    f = NAN;
                else
                    f = x;
                continue;
            }
            if (isinf(f)) continue;

            t = f + x;
            if (fabs(f) &gt;= fabs(x))
                c += ((f - t) + x);
            else
                c += ((x - t) + f);
            f = t;
        }
        f += c;
        return DBL2NUM(f);

      not_float:
        v = DBL2NUM(f);
    }

    goto has_some_value;
    init_is_a_value:
    for (; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
      has_some_value:
        v = rb_funcall(v, idPLUS, 1, e);
    }
    return v;
}</pre>
          </div>
          <p>With no block given, returns the sum of <code>init</code> and all elements of <code>self</code>; for array <code>array</code> and value <code>init</code>, equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">sum</span> = <span class="ruby-identifier">init</span>
<span class="ruby-identifier">array</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">element</span> }
<span class="ruby-identifier">sum</span>
</pre>

<p>For example, <code>[e0, e1, e2].sum</code> returns <code>init + e0 + e1 + e2</code>.</p>

<p>Examples:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">sum</span>                 <span class="ruby-comment"># =&gt; 6</span>
[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">sum</span>(<span class="ruby-value">100</span>)            <span class="ruby-comment"># =&gt; 106</span>
[<span class="ruby-string">&#39;abc&#39;</span>, <span class="ruby-string">&#39;def&#39;</span>, <span class="ruby-string">&#39;ghi&#39;</span>].<span class="ruby-identifier">sum</span>(<span class="ruby-string">&#39;jkl&#39;</span>) <span class="ruby-comment"># =&gt; &quot;jklabcdefghi&quot;</span>
[[<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>], [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>]].<span class="ruby-identifier">sum</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>])
<span class="ruby-comment"># =&gt; [2, 3, :foo, :bar, &quot;foo&quot;, &quot;bar&quot;]</span>
</pre>

<p>The <code>init</code> value and elements need not be numeric, but must all be <code>+</code>-compatible:</p>

<pre class="ruby"><span class="ruby-comment"># Raises TypeError: Array can&#39;t be coerced into Integer.</span>
[[<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>], [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>]].<span class="ruby-identifier">sum</span>(<span class="ruby-value">2</span>)
</pre>

<p>With a block given, calls the block with each element of <code>self</code>; the block’s return value (instead of the element itself) is used as the addend:</p>

<pre class="ruby">[<span class="ruby-string">&#39;zero&#39;</span>, <span class="ruby-value">1</span>, <span class="ruby-value">:two</span>].<span class="ruby-identifier">sum</span>(<span class="ruby-string">&#39;Coerced and concatenated: &#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">to_s</span> }
<span class="ruby-comment"># =&gt; &quot;Coerced and concatenated: zero1two&quot;</span>
</pre>

<p>Notes:</p>
<ul><li>
<p><a href="Array.html#method-i-join"><code>Array#join</code></a> and <a href="Array.html#method-i-flatten"><code>Array#flatten</code></a> may be faster than <a href="Array.html#method-i-sum"><code>Array#sum</code></a> for an array of strings or an array of arrays.</p>
</li><li>
<p><a href="Array.html#method-i-sum"><code>Array#sum</code></a> method may not respect method redefinition of “+” methods such as <a href="Integer.html#method-i-2B"><code>Integer#+</code></a>.</p>
</li></ul>
        </div>


      </div>

      <div id="method-i-take" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-take" title="Link to this method">
                  <span class="method-callseq">
                    take(count) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="take-source">
            <pre>static VALUE
rb_ary_take(VALUE obj, VALUE n)
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }
    return rb_ary_subseq(obj, 0, len);
}</pre>
          </div>
          <p>Returns a new array containing the first <code>count</code> element of <code>self</code> (as available); <code>count</code> must be a non-negative numeric; does not modify <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">2.1</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">50</span>)  <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-take_while" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-take_while" title="Link to this method">
                  <span class="method-callseq">
                    take_while {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-take_while" title="Link to this method">
                  <span class="method-callseq">
                    take_while &rarr; new_enumerator
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="take_while-source">
            <pre>static VALUE
rb_ary_take_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}</pre>
          </div>
          <p>With a block given, calls the block with each successive element of <code>self</code>; stops iterating if the block returns <code>false</code> or <code>nil</code>; returns a new array containing those elements for which the block returned a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-keyword">true</span> }        <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-keyword">false</span> }       <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>With no block given, returns a new <a href="Enumerator.html"><code>Enumerator</code></a>.</p>

<p>Does not modify <code>self</code>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-to_a" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-to_a" title="Link to this method">
                  <span class="method-callseq">
                    to_a &rarr; self or new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="to_a-source">
            <pre>static VALUE
rb_ary_to_a(VALUE ary)
{
    if (rb_obj_class(ary) != rb_cArray) {
        VALUE dup = rb_ary_new2(RARRAY_LEN(ary));
        rb_ary_replace(dup, ary);
        return dup;
    }
    return ary;
}</pre>
          </div>
          <p>When <code>self</code> is an instance of <a href="Array.html"><code>Array</code></a>, returns <code>self</code>.</p>

<p>Otherwise, returns a new array containing the elements of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyArray</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Array</span>; <span class="ruby-keyword">end</span>
<span class="ruby-identifier">my_a</span> = <span class="ruby-constant">MyArray</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;two&#39;</span>])
<span class="ruby-identifier">a</span> = <span class="ruby-identifier">my_a</span>.<span class="ruby-identifier">to_a</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;two&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Array # Not MyArray.</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


      </div>

      <div id="method-i-to_ary" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-to_ary" title="Link to this method">
                  <span class="method-callseq">
                    to_ary &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="to_ary-source">
            <pre>static VALUE
rb_ary_to_ary_m(VALUE ary)
{
    return ary;
}</pre>
          </div>
          <p>Returns <code>self</code>.</p>
        </div>


      </div>

      <div id="method-i-to_h" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-to_h" title="Link to this method">
                  <span class="method-callseq">
                    to_h &rarr; new_hash
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-to_h" title="Link to this method">
                  <span class="method-callseq">
                    to_h {|element| ... } &rarr; new_hash
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="to_h-source">
            <pre>static VALUE
rb_ary_to_h(VALUE ary)
{
    long i;
    VALUE hash = rb_hash_new_with_size(RARRAY_LEN(ary));
    int block_given = rb_block_given_p();

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        const VALUE e = rb_ary_elt(ary, i);
        const VALUE elt = block_given ? rb_yield_force_blockarg(e) : e;
        const VALUE key_value_pair = rb_check_array_type(elt);
        if (NIL_P(key_value_pair)) {
            rb_raise(rb_eTypeError, &quot;wrong element type %&quot;PRIsVALUE&quot; at %ld (expected array)&quot;,
                     rb_obj_class(elt), i);
        }
        if (RARRAY_LEN(key_value_pair) != 2) {
            rb_raise(rb_eArgError, &quot;wrong array length at %ld (expected 2, was %ld)&quot;,
                i, RARRAY_LEN(key_value_pair));
        }
        rb_hash_aset(hash, RARRAY_AREF(key_value_pair, 0), RARRAY_AREF(key_value_pair, 1));
    }
    return hash;
}</pre>
          </div>
          <p>Returns a new hash formed from <code>self</code>.</p>

<p>With no block given, each element of <code>self</code> must be a 2-element sub-array; forms each sub-array into a key-value pair in the new hash:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [[<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;zero&#39;</span>], [<span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;one&#39;</span>], [<span class="ruby-string">&#39;baz&#39;</span>, <span class="ruby-string">&#39;two&#39;</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_h</span> <span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;&quot;zero&quot;, &quot;bar&quot;=&gt;&quot;one&quot;, &quot;baz&quot;=&gt;&quot;two&quot;}</span>
[].<span class="ruby-identifier">to_h</span> <span class="ruby-comment"># =&gt; {}</span>
</pre>

<p>With a block given, the block must return a 2-element array; calls the block with each element of <code>self</code>; forms each returned array into a key-value pair in the returned hash:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], {<span class="ruby-value">baz:</span> <span class="ruby-value">4</span>}]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">to_h</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">element</span>, <span class="ruby-identifier">element</span>.<span class="ruby-identifier">class</span>] }
<span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;String, :bar=&gt;Symbol, 1=&gt;Integer, [2, 3]=&gt;Array, {:baz=&gt;4}=&gt;Hash}</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


      </div>

      <div id="method-i-to_s" class="method-detail anchor-link method-alias">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-to_s" title="Link to this method">
                  <span class="method-callseq">
                    to_s &rarr; new_string
                  </span>
                </a>
              </div>
        </div>


        <div class="method-description">
          <p>Returns the new string formed by calling method <a href="Array.html#method-i-inspect"><code>inspect</code></a> on each array element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">inspect</span> <span class="ruby-comment"># =&gt; &quot;[:foo, \&quot;bar\&quot;, 2]&quot;</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


        <div class="aliases">
          Alias for: <a href="Array.html#method-i-inspect">inspect</a>
        </div>
      </div>

      <div id="method-i-transpose" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-transpose" title="Link to this method">
                  <span class="method-callseq">
                    transpose &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="transpose-source">
            <pre>static VALUE
rb_ary_transpose(VALUE ary)
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY_LEN(ary);
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
        tmp = to_ary(rb_ary_elt(ary, i));
        if (elen &lt; 0) {         /* first element */
            elen = RARRAY_LEN(tmp);
            result = rb_ary_new2(elen);
            for (j=0; j&lt;elen; j++) {
                rb_ary_store(result, j, rb_ary_new2(alen));
            }
        }
        else if (elen != RARRAY_LEN(tmp)) {
            rb_raise(rb_eIndexError, &quot;element size differs (%ld should be %ld)&quot;,
                     RARRAY_LEN(tmp), elen);
        }
        for (j=0; j&lt;elen; j++) {
            rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
        }
    }
    return result;
}</pre>
          </div>
          <p>Returns a new array that is <code>self</code> as a <a href="https://en.wikipedia.org/wiki/Transpose">transposed matrix</a>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [[<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>], [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>], [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">transpose</span> <span class="ruby-comment"># =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1]]</span>
</pre>

<p>The elements of <code>self</code> must all be the same size.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


      </div>

      <div id="method-i-union" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-union" title="Link to this method">
                  <span class="method-callseq">
                    union(*other_arrays) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="union-source">
            <pre>static VALUE
rb_ary_union_multi(int argc, VALUE *argv, VALUE ary)
{
    int i;
    long sum;
    VALUE hash;

    sum = RARRAY_LEN(ary);
    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        sum += RARRAY_LEN(argv[i]);
    }

    if (sum &lt;= SMALL_ARRAY_LEN) {
        VALUE ary_union = rb_ary_new();

        rb_ary_union(ary_union, ary);
        for (i = 0; i &lt; argc; i++) rb_ary_union(ary_union, argv[i]);

        return ary_union;
    }

    hash = ary_make_hash(ary);
    for (i = 0; i &lt; argc; i++) rb_ary_union_hash(hash, argv[i]);

    return rb_hash_values(hash);
}</pre>
          </div>
          <p>Returns a new array that is the union of the elements of <code>self</code> and all given arrays <code>other_arrays</code>; items are compared using <code>eql?</code>:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">union</span>([<span class="ruby-value">4</span>, <span class="ruby-value">5</span>], [<span class="ruby-value">6</span>, <span class="ruby-value">7</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2, 3, 4, 5, 6, 7]</span>
</pre>

<p>Removes duplicates (preserving the first found):</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">union</span>([<span class="ruby-value">2</span>, <span class="ruby-value">1</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; [0, 1, 2, 3]</span>
</pre>

<p>Preserves order (preserving the position of the first found):</p>

<pre class="ruby">[<span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">union</span>([<span class="ruby-value">5</span>, <span class="ruby-value">3</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">2</span>]) <span class="ruby-comment"># =&gt; [3, 2, 1, 0, 5, 4]</span>
</pre>

<p>With no arguments given, returns a copy of <code>self</code>.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p>
        </div>


      </div>

      <div id="method-i-uniq" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-uniq" title="Link to this method">
                  <span class="method-callseq">
                    uniq &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-uniq" title="Link to this method">
                  <span class="method-callseq">
                    uniq {|element| ... } &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="uniq-source">
            <pre>static VALUE
rb_ary_uniq(VALUE ary)
{
    VALUE hash, uniq;

    if (RARRAY_LEN(ary) &lt;= 1) {
        hash = 0;
        uniq = rb_ary_dup(ary);
    }
    else if (rb_block_given_p()) {
        hash = ary_make_hash_by(ary);
        uniq = rb_hash_values(hash);
    }
    else {
        hash = ary_make_hash(ary);
        uniq = rb_hash_values(hash);
    }

    return uniq;
}</pre>
          </div>
          <p>Returns a new array containing those elements from <code>self</code> that are not duplicates, the first occurrence always being retained.</p>

<p>With no block given, identifies and omits duplicate elements using method <code>eql?</code> to compare elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>

<p>With a block given, calls the block for each element; identifies and omits “duplicate” elements using method <code>eql?</code> to compare <em>block return values</em>; that is, an element is a duplicate if its block return value is the same as that of a previous element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;aa&#39;</span>, <span class="ruby-string">&#39;aaa&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;bb&#39;</span>, <span class="ruby-string">&#39;bbb&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;]</span>
</pre>

<p>Related: <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-uniq-21" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-uniq-21" title="Link to this method">
                  <span class="method-callseq">
                    uniq! &rarr; self or nil
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-uniq-21" title="Link to this method">
                  <span class="method-callseq">
                    uniq! {|element| ... } &rarr; self or nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="uniq-21-source">
            <pre>static VALUE
rb_ary_uniq_bang(VALUE ary)
{
    VALUE hash;
    long hash_size;

    rb_ary_modify_check(ary);
    if (RARRAY_LEN(ary) &lt;= 1)
        return Qnil;
    if (rb_block_given_p())
        hash = ary_make_hash_by(ary);
    else
        hash = ary_make_hash(ary);

    hash_size = RHASH_SIZE(hash);
    if (RARRAY_LEN(ary) == hash_size) {
        return Qnil;
    }
    rb_ary_modify_check(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_SHARED_P(ary)) {
        rb_ary_unshare(ary);
        FL_SET_EMBED(ary);
    }
    ary_resize_capa(ary, hash_size);
    rb_hash_foreach(hash, push_value, ary);

    return ary;
}</pre>
          </div>
          <p>Removes duplicate elements from <code>self</code>, the first occurrence always being retained; returns <code>self</code> if any elements removed, <code>nil</code> otherwise.</p>

<p>With no block given, identifies and removes elements using method <code>eql?</code> to compare elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>With a block given, calls the block for each element; identifies and omits “duplicate” elements using method <code>eql?</code> to compare <em>block return values</em>; that is, an element is a duplicate if its block return value is the same as that of a previous element:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;aa&#39;</span>, <span class="ruby-string">&#39;aaa&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;bb&#39;</span>, <span class="ruby-string">&#39;bbb&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">size</span> } <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p>
        </div>


      </div>

      <div id="method-i-unshift" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-unshift" title="Link to this method">
                  <span class="method-callseq">
                    unshift(*objects) &rarr; self
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="unshift-source">
            <pre>VALUE
rb_ary_unshift_m(int argc, VALUE *argv, VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE target_ary;

    if (argc == 0) {
        rb_ary_modify_check(ary);
        return ary;
    }

    target_ary = ary_ensure_room_for_unshift(ary, argc);
    ary_memcpy0(ary, 0, argc, argv, target_ary);
    ARY_SET_LEN(ary, len + argc);
    return ary;
}</pre>
          </div>
          <p>Prepends the given <code>objects</code> to <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:foo</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">:bam</span>, <span class="ruby-value">:bat</span>) <span class="ruby-comment"># =&gt; [:bam, :bat, :foo, &quot;bar&quot;, 2]</span>
</pre>

<p>Related: <a href="Array.html#method-i-shift"><code>Array#shift</code></a>; see also <a href="Array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Array.html#method-i-prepend">prepend</a>
        </div>

      </div>

      <div id="method-i-values_at" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-values_at" title="Link to this method">
                  <span class="method-callseq">
                    values_at(*specifiers) &rarr; new_array
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="values_at-source">
            <pre>static VALUE
rb_ary_values_at(int argc, VALUE *argv, VALUE ary)
{
    long i, olen = RARRAY_LEN(ary);
    VALUE result = rb_ary_new_capa(argc);
    for (i = 0; i &lt; argc; ++i) {
        append_values_at_single(result, ary, olen, argv[i]);
    }
    RB_GC_GUARD(ary);
    return result;
}</pre>
          </div>
          <p>Returns elements from <code>self</code> in a new array; does not modify <code>self</code>.</p>

<p>The objects included in the returned array are the elements of <code>self</code> selected by the given <code>specifiers</code>, each of which must be a numeric index or a <a href="Range.html"><code>Range</code></a>.</p>

<p>In brief:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]

<span class="ruby-comment"># Index specifiers.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span>, <span class="ruby-value">0</span>)     <span class="ruby-comment"># =&gt; [&quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;] # May repeat.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-4</span>, <span class="ruby-value">-3</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] # Counts backwards if negative.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-50</span>, <span class="ruby-value">50</span>)        <span class="ruby-comment"># =&gt; [nil, nil]           # Outside of self.</span>

<span class="ruby-comment"># Range specifiers.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>)       <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;] # From range.begin to range.end.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">3</span>)      <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;]      # End excluded.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>)       <span class="ruby-comment"># =&gt; []              # No such elements.</span>

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-3</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]     # Negative range.begin counts backwards.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-50</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>)                          <span class="ruby-comment"># Raises RangeError.</span>

<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>)  <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;]          # Negative range.end counts backwards.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-50</span>) <span class="ruby-comment"># =&gt; []                  # No such elements.</span>

<span class="ruby-comment"># Mixture of specifiers.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>, <span class="ruby-value">3</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [&quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>

<p>With no <code>specifiers</code> given, returns a new empty array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-string">&#39;b&#39;</span>, <span class="ruby-string">&#39;c&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span> <span class="ruby-comment"># =&gt; []</span>
</pre>

<p>For each numeric specifier <code>index</code>, includes an element:</p>
<ul><li>
<p>For each non-negative numeric specifier <code>index</code> that is in-range (less than <code>self.size</code>), includes the element at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">0</span>, <span class="ruby-value">2</span>)     <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">0.1</span>, <span class="ruby-value">2.9</span>) <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;c&quot;]</span>
</pre>
</li><li>
<p>For each negative numeric <code>index</code> that is in-range (greater than or equal to <code>- self.size</code>), counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-1</span>, <span class="ruby-value">-4</span>) <span class="ruby-comment"># =&gt; [&quot;d&quot;, &quot;a&quot;]</span>
</pre>
</li></ul>

<p>The given indexes may be in any order, and may repeat:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;]</span>
</pre>

<p>For each <code>index</code> that is out-of-range, includes <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">4</span>, <span class="ruby-value">-5</span>) <span class="ruby-comment"># =&gt; [nil, nil]</span>
</pre>

<p>For each <a href="Range.html"><code>Range</code></a> specifier <code>range</code>, includes elements according to <code>range.begin</code> and <code>range.end</code>:</p>
<ul><li>
<p>If both <code>range.begin</code> and <code>range.end</code> are non-negative and in-range (less than <code>self.size</code>), includes elements from index <code>range.begin</code> through <code>range.end - 1</code> (if <code>range.exclude_end?</code>), or through <code>range.end</code> (otherwise):</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)  <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">...</span><span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;b&quot;]</span>
</pre>
</li><li>
<p>If <code>range.begin</code> is negative and in-range (greater than or equal to <code>- self.size</code>), counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [&quot;c&quot;, &quot;d&quot;]</span>
</pre>
</li><li>
<p>If <code>range.begin</code> is negative and out-of-range, raises an exception:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-5</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>) <span class="ruby-comment"># Raises RangeError.</span>
</pre>
</li><li>
<p>If <code>range.end</code> is positive and out-of-range, extends the returned array with <code>nil</code> elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>) <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, nil, nil]</span>
</pre>
</li><li>
<p>If <code>range.end</code> is negative and in-range, counts backwards from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;c&quot;]</span>
</pre>
</li><li>
<p>If <code>range.end</code> is negative and out-of-range, returns an empty array:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-5</span>) <span class="ruby-comment"># =&gt; []</span>
</pre>
</li></ul>

<p>The given ranges may be in any order and may repeat:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>, <span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [&quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>The given specifiers may be any mixture of indexes and ranges:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">3</span>, <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>, <span class="ruby-value">0</span>, <span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p>
        </div>


      </div>

      <div id="method-i-zip" class="method-detail anchor-link ">
        <div class="method-header">
              <div class="method-heading">
                <a href="#method-i-zip" title="Link to this method">
                  <span class="method-callseq">
                    zip(*other_arrays) &rarr; new_array
                  </span>
                </a>
              </div>
              <div class="method-heading">
                <a href="#method-i-zip" title="Link to this method">
                  <span class="method-callseq">
                    zip(*other_arrays) {|sub_array| ... } &rarr; nil
                  </span>
                </a>
              </div>
        </div>

          <div class="method-controls">
            <details class="method-source-toggle">
              <summary>Source</summary>
            </details>
          </div>

        <div class="method-description">
          <div class="method-source-code" id="zip-source">
            <pre>static VALUE
rb_ary_zip(int argc, VALUE *argv, VALUE ary)
{
    int i, j;
    long len = RARRAY_LEN(ary);
    VALUE result = Qnil;

    for (i=0; i&lt;argc; i++) {
        argv[i] = take_items(argv[i], len);
    }

    if (rb_block_given_p()) {
        int arity = rb_block_arity();

        if (arity &gt; 1) {
            VALUE work, *tmp;

            tmp = ALLOCV_N(VALUE, work, argc+1);

            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                tmp[0] = RARRAY_AREF(ary, i);
                for (j=0; j&lt;argc; j++) {
                    tmp[j+1] = rb_ary_elt(argv[j], i);
                }
                rb_yield_values2(argc+1, tmp);
            }

            if (work) ALLOCV_END(work);
        }
        else {
            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                VALUE tmp = rb_ary_new2(argc+1);

                rb_ary_push(tmp, RARRAY_AREF(ary, i));
                for (j=0; j&lt;argc; j++) {
                    rb_ary_push(tmp, rb_ary_elt(argv[j], i));
                }
                rb_yield(tmp);
            }
        }
    }
    else {
        result = rb_ary_new_capa(len);

        for (i=0; i&lt;len; i++) {
            VALUE tmp = rb_ary_new_capa(argc+1);

            rb_ary_push(tmp, RARRAY_AREF(ary, i));
            for (j=0; j&lt;argc; j++) {
                rb_ary_push(tmp, rb_ary_elt(argv[j], i));
            }
            rb_ary_push(result, tmp);
        }
    }

    return result;
}</pre>
          </div>
          <p>With no block given, combines <code>self</code> with the collection of <code>other_arrays</code>; returns a new array of sub-arrays:</p>

<pre class="ruby">[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">zip</span>([<span class="ruby-string">&#39;zero&#39;</span>, <span class="ruby-string">&#39;one&#39;</span>], [<span class="ruby-value">:zero</span>, <span class="ruby-value">:one</span>])
<span class="ruby-comment"># =&gt; [[0, &quot;zero&quot;, :zero], [1, &quot;one&quot;, :one]]</span>
</pre>

<p>Returned:</p>
<ul><li>
<p>The outer array is of size <code>self.size</code>.</p>
</li><li>
<p>Each sub-array is of size <code>other_arrays.size + 1</code>.</p>
</li><li>
<p>The <em>nth</em> sub-array contains (in order):</p>
<ul><li>
<p>The <em>nth</em> element of <code>self</code>.</p>
</li><li>
<p>The <em>nth</em> element of each of the other arrays, as available.</p>
</li></ul>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
<span class="ruby-identifier">zipped</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>([<span class="ruby-string">&#39;zero&#39;</span>, <span class="ruby-string">&#39;one&#39;</span>], [<span class="ruby-value">:zero</span>, <span class="ruby-value">:one</span>])
<span class="ruby-comment"># =&gt; [[0, &quot;zero&quot;, :zero], [1, &quot;one&quot;, :one]]</span>
<span class="ruby-identifier">zipped</span>.<span class="ruby-identifier">size</span>       <span class="ruby-comment"># =&gt; 2 # Same size as a.</span>
<span class="ruby-identifier">zipped</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">size</span> <span class="ruby-comment"># =&gt; 3 # Size of other arrays plus 1.</span>
</pre>

<p>When the other arrays are all the same size as <code>self</code>, the returned sub-arrays are a rearrangement containing exactly elements of all the arrays (including <code>self</code>), with no omissions or additions:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:b3</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>, <span class="ruby-value">:c2</span>, <span class="ruby-value">:c3</span>]
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>)
<span class="ruby-identifier">pp</span> <span class="ruby-identifier">d</span>
<span class="ruby-comment"># =&gt;</span>
[[<span class="ruby-value">:a0</span>, <span class="ruby-value">:b0</span>, <span class="ruby-value">:c0</span>],
 [<span class="ruby-value">:a1</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:c1</span>],
 [<span class="ruby-value">:a2</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:c2</span>],
 [<span class="ruby-value">:a3</span>, <span class="ruby-value">:b3</span>, <span class="ruby-value">:c3</span>]]
</pre>

<p>When one of the other arrays is smaller than <code>self</code>, pads the corresponding sub-array with <code>nil</code> elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>]
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>)
<span class="ruby-identifier">pp</span> <span class="ruby-identifier">d</span>
<span class="ruby-comment"># =&gt;</span>
[[<span class="ruby-value">:a0</span>, <span class="ruby-value">:b0</span>, <span class="ruby-value">:c0</span>],
 [<span class="ruby-value">:a1</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:c1</span>],
 [<span class="ruby-value">:a2</span>, <span class="ruby-value">:b2</span>, <span class="ruby-keyword">nil</span>],
 [<span class="ruby-value">:a3</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>]]
</pre>

<p>When one of the other arrays is larger than <code>self</code>, <em>ignores</em> its trailing elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:b3</span>, <span class="ruby-value">:b4</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>, <span class="ruby-value">:c2</span>, <span class="ruby-value">:c3</span>, <span class="ruby-value">:c4</span>, <span class="ruby-value">:c5</span>]
<span class="ruby-identifier">d</span> = <span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>)
<span class="ruby-identifier">pp</span> <span class="ruby-identifier">d</span>
<span class="ruby-comment"># =&gt;</span>
[[<span class="ruby-value">:a0</span>, <span class="ruby-value">:b0</span>, <span class="ruby-value">:c0</span>],
 [<span class="ruby-value">:a1</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:c1</span>],
 [<span class="ruby-value">:a2</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:c2</span>],
 [<span class="ruby-value">:a3</span>, <span class="ruby-value">:b3</span>, <span class="ruby-value">:c3</span>]]
</pre>

<p>With a block given, calls the block with each of the other arrays; returns <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = []
<span class="ruby-identifier">a</span> = [<span class="ruby-value">:a0</span>, <span class="ruby-value">:a1</span>, <span class="ruby-value">:a2</span>, <span class="ruby-value">:a3</span>]
<span class="ruby-identifier">b</span> = [<span class="ruby-value">:b0</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:b3</span>]
<span class="ruby-identifier">c</span> = [<span class="ruby-value">:c0</span>, <span class="ruby-value">:c1</span>, <span class="ruby-value">:c2</span>, <span class="ruby-value">:c3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">sub_array</span><span class="ruby-operator">|</span> <span class="ruby-identifier">d</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">sub_array</span>.<span class="ruby-identifier">reverse</span>) } <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">pp</span> <span class="ruby-identifier">d</span>
<span class="ruby-comment"># =&gt;</span>
[[<span class="ruby-value">:c0</span>, <span class="ruby-value">:b0</span>, <span class="ruby-value">:a0</span>],
 [<span class="ruby-value">:c1</span>, <span class="ruby-value">:b1</span>, <span class="ruby-value">:a1</span>],
 [<span class="ruby-value">:c2</span>, <span class="ruby-value">:b2</span>, <span class="ruby-value">:a2</span>],
 [<span class="ruby-value">:c3</span>, <span class="ruby-value">:b3</span>, <span class="ruby-value">:a3</span>]]
</pre>

<p>For an <strong>object</strong> in <strong>other_arrays</strong> that is not actually an array, forms the the “other array” as <code>object.to_ary</code>, if defined, or as <code>object.each.to_a</code> otherwise.</p>

<p>Related: see <a href="Array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p>
        </div>


      </div>

    </section>

  </section>
</main>

